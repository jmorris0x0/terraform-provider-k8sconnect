CRITICAL BUGS & FIXES

Easy:
* Add url attribute to yaml_split to load from the web url, OCI, and git repo/path/branch. Won't do. There is already an http datasource. Just make an example that uses it.

* error if more than one context in kubeconfig and context is not given. Plus test. Using current context or first context is dangerous.

* The readme example: "The yaml_split data source creates stable IDs like deployment.my-app.nginx and service.my-app.nginx, preventing unnecessary resource recreation when manifests are reordered." Can these collide? Do we need more entroy? Should it really be deployment.app.nginx based on the example? Make a runnable example maybe? what if two yaml_split resources put their output into one map? Would there be dupes?

Hard:
* Finish MVP of existing resource datasource and add wait_for. Actually, this might not be a good idea. 
Datasources run during plan phase even with depends_on, so they can't wait for resources that don't exist yet. The only exception is when datasource inputs are unknown (forcing deferral to apply), but "resource might not exist" isn't the same as "input value unknown". For waiting on resources created by other systems, you'd need a separate wait resource, not a waiting datasource.


https://registry.terraform.io/providers/hashicorp/kubernetes/latest/docs/data-sources/resource
GB doesn't have one!

* Solve import syntax issue for api version
GB does this:
   # Import the my-namespace Namespace
   terraform import kubectl_manifest.my-namespace v1//Namespace//my-namespace

   # Import the certmanager Issuer CRD named cluster-selfsigned-issuer-root-ca from the my-namespace namespace
   $ terraform import -provider kubectl module.kubernetes.kubectl_manifest.crd-example certmanager.k8s.io/v1alpha1//Issuer//cluster-selfsigned-issuer-root-ca//my-namespace

* UX of yaml split needs a lot of work. It works as an MVP but the existing filtering by regex is quite awkward. API needs redesign before alpha. Don't even start with the patch resource until this one is totally polished. At minimum, expose yaml fields as attributes so people can filter. That's easy. Consider adding a filter field of some kind.
67b38a3f-368f-461d-ad12-ffc7b541cac3


DOCUMENTATION & RELEASE

Registry landing page: Write main docs
Verify attribute docs: Status changes need documentation updates
Fill community standards: Issue templates, contributing guide, etc.
Example improvements: Show both inline and template file patterns
Don't need the first load balancer example. Find a different one or delete.

Nested Schema for wait_for: Needs love


TESTING GAPS

Ownership edge cases: Create transition matrix and acceptance tests for all ownership scenarios
Ownership conflict test: Test without force_conflicts=true (item 27)
Import blocks: Verify they work correctly
Cluster connection validation: Complex attribute combinations need better testing
Datasource testing: Dependency graph, unknowns handling, interpolation
OpenTofu tests: Add compatibility testing
Check for stubs/skips: Audit test suite for forgotten temporary code
HPA simulation: Test multiple simultaneous ownership changes
Find a way to test multicluster
Test very large CRDs. This was an issue in other providers. might need chunking.
Delayed plan application: Handle out-of-date plans
Add examples tests for datasource
Use latest for all example images. Otherwise just making toil for later.

FEATURE ADDITIONS

Custom ownership annotations: Solve cross-state conflicts
Full JSON manifest: Make available as computed attribute. I think this is table stakes for parity. At least one of the other two have this. Take a look. I might already have this?
Status field guardrails: Warn if field doesn't start with "status"
Adding a patch resource would be a big differentiator. Not sure if wise though.

UX IMPROVEMENTS

Remove field_ownership from diffs: Just noise in output. This is fixed by moving to map.
Hide private attributes: Some should not be in UI
YAML diff vs dry-run diff: Evaluate which is better UX
Datasource args: Flatten nested structure unless adding more attributes
Better datasource errors: Improve error messages
Warnings for old versions: Terraform <1.6 or pre-SSA Kubernetes
Lock down the interface before launch: The attributes and behavior I ship with will haunt me for years.
https://registry.terraform.io/providers/gavinbunney/kubectl/latest/docs/resources/kubectl_manifest#attribute-reference
https://registry.terraform.io/providers/hashicorp/kubernetes/latest/docs/resources/manifest
GB has many yaml helper datasources. I just have one. Good design decsion? Or no?


CODE QUALITY

Cyclomatic complexity: Reduce all functions to <15
General refactoring: Simplification pass
Convert to issues: Move this list to GitHub issues
Share same wait/watch/polling code between all actions. Move to common?
Security scanning alerts: Address current GitHub code scanning issues

MARKETING & GROWTH

SEO optimization: Is "k8sconnect" optimal for discovery?
Launch content: Medium article, r/kubernetes, r/terraform, HackerNews posts, SweetOps Slack, Kubernetes Slack
Release pipeline: Add Tofu release, verify Windows/Linux builds

DEFERRED/COMPLEX

Dynamic datasource lookup: Use same JSON-to-attribute logic as resource
Migration plan for other providers
Rename managed_state_projection. No!
Fix makefile to install all dependencies. Try on fresh laptop.
Add back cluster_info datasource that has more info than GB:
https://registry.terraform.io/providers/gavinbunney/kubectl/latest/docs/data-sources/kubectl_server_version
yaml_split intelligent reordering by default? Can't do this if we output to a simple map. (Do we use map? I hope so. Check!)

Migration tooling!
"Stuck with thousands of lines of Kubernetes HCL? We'll help you escape."
hcl2yaml main.tf > manifests.yaml
Could probably knock out an MVP using the Terraform provider schema definitions to reverse the translation.


  Critical Gaps to Address

  Must-Have Before Release:

  1. Import documentation
    - Your format, examples, behavior
    - Critical - people need to migrate existing resources

  Should Consider:

  4. field_manager_name - let users control the field manager identity
    - Useful for debugging SSA conflicts
    - HashiCorp has this, I auto-generate
    - Could be quite complex?
  5. sensitive_fields - mask arbitrary fields in state
    - kubectl has this for custom masking
    - You only mask connection credentials
    - Meh. Easy to add later if people complain.
  6. override_namespace - apply to different namespace than YAML specifies
    - kubectl has this
    - Useful for multi-tenancy patterns
    - Could be nice. Not sure how hard.


Under the readme main table I say "Conventional providers" I need to make sure that all these things apply to both hashi and gavin. Otherwise i'm not being fair. Gotta be nice.

Update git repo tag line for new focus on single stage apply.

Add override_namespace to manifest resource for multi-tenancy patterns

Unmet needs and pain points:

Unified State Management: A tool that bridges Terraform's state with Kubernetes' native reconciliation without drift wars. [I address this already]

Rollbacks in Terraform often mean disruptive destroy-and-recreate cycles, while Kubernetes can do rapid, surgical rollbacks in seconds. [I could address this?]

Terraform wants to be declarative and stateful, Kubernetes wants to be self-healing and continuously reconciling, and developers just want to ship code without becoming infrastructure experts.



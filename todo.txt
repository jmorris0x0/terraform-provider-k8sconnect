CRITICAL BUGS & FIXES

Easy:
* Add url attribute to yaml_split to load from the web url, OCI, and git repo/path/branch. Won't do. There is already an http datasource. Just make an example that uses it.

* error if more than one context in kubeconfig and context is not given. Plus test. Using current context or first context is dangerous.

* The readme example: "The yaml_split data source creates stable IDs like deployment.my-app.nginx and service.my-app.nginx, preventing unnecessary resource recreation when manifests are reordered." Can these collide? Do we need more entroy? Should it really be deployment.app.nginx based on the example? Make a runnable example maybe? what if two yaml_split resources put their output into one map? Would there be dupes?

Hard:
* Fix flaky test: yaml-split-dependency-ordering fails due to CRD race condition. Add option to yaml_split to order CRD first? Similar issue with namespaces.

* Centralize wait/polling/watch code?

* Finish MVP of existing resource datasource and add wait_for. Actually, this might not be a good idea. 
Datasources run during plan phase even with depends_on, so they can't wait for resources that don't exist yet. The only exception is when datasource inputs are unknown (forcing deferral to apply), but "resource might not exist" isn't the same as "input value unknown". For waiting on resources created by other systems, you'd need a separate wait resource, not a waiting datasource.


https://registry.terraform.io/providers/hashicorp/kubernetes/latest/docs/data-sources/resource
GB doesn't have one!

* Solve import syntax issue for api version
GB does this:
   # Import the my-namespace Namespace
   terraform import kubectl_manifest.my-namespace v1//Namespace//my-namespace

   # Import the certmanager Issuer CRD named cluster-selfsigned-issuer-root-ca from the my-namespace namespace
   $ terraform import -provider kubectl module.kubernetes.kubectl_manifest.crd-example certmanager.k8s.io/v1alpha1//Issuer//cluster-selfsigned-issuer-root-ca//my-namespace

* UX of yaml split needs a lot of work. It works as an MVP but the existing filtering by regex is quite awkward. API needs redesign before alpha. Don't even start with the patch resource until this one is totally polished. At minimum, expose yaml fields as attributes so people can filter. That's easy. Consider adding a filter field of some kind.
67b38a3f-368f-461d-ad12-ffc7b541cac3


DOCUMENTATION & RELEASE

Registry landing page: Write main docs
Verify attribute docs: Status changes need documentation updates
Key features placement: Move higher in docs
Add token example: To connection methods section
Fill community standards: Issue templates, contributing guide, etc.
Example improvements: Show both inline and template file patterns
Don't need the first load balancer example. Find a different one or delete.

This docstring is wrong:
"cluster_connection (Attributes) Cluster connection configuration for this resource. If not specified, uses the provider-level connection."

Nested Schema for wait_for: Needs love


TESTING GAPS

Ownership edge cases: Create transition matrix and acceptance tests for all ownership scenarios
Ownership conflict test: Test without force_conflicts=true (item 27)
Import blocks: Verify they work correctly
Cluster connection validation: Complex attribute combinations need better testing
Datasource testing: Dependency graph, unknowns handling, interpolation
OpenTofu tests: Add compatibility testing
Check for stubs/skips: Audit test suite for forgotten temporary code
HPA simulation: Test multiple simultaneous ownership changes
What happens when try to do something is not authorized? Do you find out during plan? Need a test for this!
It's not just plans and applies that need auth. There is also patch, watch, etc. This will be a very common problem.
Find a way to test multicluster
Test very large CRDs. This was an issue in other providers. might need chunking.
Delayed plan application: Handle out-of-date plans
Add examples tests for datasource
Use latest for all example images. Otherwise just making toil for later.

FEATURE ADDITIONS

Custom ownership annotations: Solve cross-state conflicts
Full JSON manifest: Make available as computed attribute. I think this is table stakes for parity. At least one of the other two have this. Take a look.
Status field guardrails: Warn if field doesn't start with "status"
Adding a patch resource would be a big differentiator. Not sure if wise though.

UX IMPROVEMENTS

Remove field_ownership from diffs: Just noise in output
Hide private attributes: Some should not be in UI
YAML diff vs dry-run diff: Evaluate which is better UX
Datasource args: Flatten nested structure unless adding more attributes
Better datasource errors: Improve error messages
Warnings for old versions: Terraform <1.6 or pre-SSA Kubernetes
Lock down the interface before launch: The attributes and behavior I ship with will haunt me for years.
https://registry.terraform.io/providers/gavinbunney/kubectl/latest/docs/resources/kubectl_manifest#attribute-reference
https://registry.terraform.io/providers/hashicorp/kubernetes/latest/docs/resources/manifest
GB has many yaml helper datasources. I just have one. Good design decsion? Or no?
Canonicalize the YAML. Or did I do this already months ago?

CODE QUALITY

Cyclomatic complexity: Reduce all functions to <15
General refactoring: Simplification pass
Convert to issues: Move this list to GitHub issues
Share same wait/watch/polling code between all actions. Move to common
Security scanning alerts: Address current GitHub code scanning issues
Remove print statements: Convert all debug prints to proper logging or remove them

MARKETING & GROWTH

SEO optimization: Is "k8sconnect" optimal for discovery?
Launch content: Medium article, r/kubernetes, r/terraform, HackerNews posts, SweetOps Slack, Kubernetes Slack
Release pipeline: Add Tofu release, verify Windows/Linux builds

DEFERRED/COMPLEX

Dynamic datasource lookup: Use same JSON-to-attribute logic as resource
Move server-side features up: In feature list
Migration plan for other providers
Remove imported_without_annotations or make private
Rename managed_state_projection
Fix makefile to install all dependencies. Try on fresh laptop.
Add back cluster_info datasource that has more info than GB:
https://registry.terraform.io/providers/gavinbunney/kubectl/latest/docs/data-sources/kubectl_server_version
yaml_split intelligent reordering by default? Can't do this if we output to a simple map. (Do we use map? I hope so. Check!)

Migration tooling!
"Stuck with thousands of lines of Kubernetes HCL? We'll help you escape."
hcl2yaml main.tf > manifests.yaml
Could probably knock out an MVP using the Terraform provider schema definitions to reverse the translation.


  Critical Gaps to Address

  Must-Have Before Release:

  1. ignore_fields - kubectl has this, you don't
    - Workaround for lifecycle.ignore_changes issues
    - Essential for operator-managed fields
    - High priority - this will be requested immediately
  2. create_timeout and update_timeout
    - You only have delete_timeout
    - HashiCorp has all three
    - Medium priority - needed for slow-applying resources
  3. Import documentation
    - Your format, examples, behavior
    - The imported_without_annotations flag needs explanation
    - Critical - people need to migrate existing resources

  Should Consider:

  4. field_manager_name - let users control the field manager identity
    - Useful for debugging SSA conflicts
    - HashiCorp has this, you auto-generate
  5. sensitive_fields - mask arbitrary fields in state
    - kubectl has this for custom masking
    - You only mask connection credentials
  6. override_namespace - apply to different namespace than YAML specifies
    - kubectl has this
    - Useful for multi-tenancy patterns

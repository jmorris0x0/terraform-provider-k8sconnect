# ADR-008: Config-First Import Strategy for k8sinline

**Status:** Accepted  
**Date:** 2025-05-24  
**Authors:** k8sinline team

## Context

The k8sinline provider stores cluster connection information **inline within each resource** rather than at the provider level. This creates a fundamental challenge for Terraform's `import` command:

### The Problem
```bash
# This cannot work - no connection info available!
terraform import k8sinline_manifest.example "default/Pod/my-pod"
```

**Root cause:** During import, Terraform calls `ImportState()` before the resource configuration exists in the plan. The provider has no way to know:
- Which cluster to connect to
- What credentials to use  
- How to authenticate

### Alternative Approaches Considered

#### 1. **Provider-Level Connection Fallback**
```hcl
provider "k8sinline" {
  # Fallback connection for imports only
  default_connection {
    kubeconfig_file = "~/.kube/config"
  }
}
```
**‚ùå Rejected:** Violates k8sinline's core design principle of per-resource connections.

#### 2. **Environment Variable Strategy**
```bash
KUBECONFIG=~/.kube/config terraform import k8sinline_manifest.nginx "default/Pod/nginx"
```
**‚ùå Rejected:** Inconsistent with inline connection model; doesn't work with exec auth.

#### 3. **Connection String in Import ID**
```bash
terraform import k8sinline_manifest.nginx "host=https://api.cluster.com;ns=default;kind=Pod;name=nginx"
```
**‚ùå Rejected:** Extremely verbose; sensitive credentials in CLI history; poor UX.

## Decision

**Implement "Config-First Import" strategy:**

1. **User must write resource configuration first** (with connection details)
2. **Import command uses connection from existing configuration**
3. **Live object overwrites placeholder YAML during import**

## Implementation

### Step 1: User Configuration
```hcl
resource "k8sinline_manifest" "nginx" {
  yaml_body = "# Placeholder - will be replaced during import"
  
  cluster_connection {
    host                   = var.cluster_endpoint
    cluster_ca_certificate = var.cluster_ca
    exec = {
      api_version = "client.authentication.k8s.io/v1" 
      command     = "aws"
      args        = ["eks", "get-token", "--cluster-name", "prod"]
    }
  }
}
```

### Step 2: Import Command
```bash
terraform import k8sinline_manifest.nginx "default/Pod/nginx-deployment-abc123"
```

### Step 3: Import Logic
```go
func (r *manifestResource) ImportState(ctx context.Context, req resource.ImportStateRequest, resp *resource.ImportStateResponse) {
    // 1. Parse import ID: "<namespace>/<kind>/<name>"
    parts := strings.Split(req.ID, "/")
    if len(parts) != 3 {
        resp.Diagnostics.AddError("Invalid Import ID", 
            "Expected format: <namespace>/<kind>/<name>")
        return
    }
    namespace, kind, name := parts[0], parts[1], parts[2]
    
    // 2. Read connection from existing configuration
    var data manifestResourceModel
    diags := req.Config.Get(ctx, &data)
    if diags.HasError() {
        resp.Diagnostics.AddError("Import Failed",
            "Resource configuration with cluster_connection required before import")
        return
    }
    
    // 3. Create K8s client from connection
    client, err := r.clientGetter(data.ClusterConnection)
    if err != nil {
        resp.Diagnostics.AddError("Connection Failed", err.Error())
        return
    }
    
    // 4. Fetch live object from cluster
    // 5. Convert to YAML and populate state
    // 6. Generate resource ID
}
```

### Import ID Format
**Chosen:** `<namespace>/<kind>/<name>`

**Examples:**
- `default/Pod/nginx-abc123`
- `kube-system/Service/coredns`  
- `production/Deployment/api-server`
- `""/Namespace/my-namespace` (empty namespace for cluster-scoped)

## Rationale

### ‚úÖ Advantages
1. **Consistent with k8sinline philosophy** - connections stay in resources
2. **No sensitive data in CLI** - credentials remain in config files
3. **Works with all connection modes** - inline, kubeconfig, exec auth
4. **Standard Terraform UX** - familiar two-step import process
5. **Secure by default** - no credential leakage to shell history
6. **Explicit and documented** - clear requirements for users

### ‚ö†Ô∏è Disadvantages  
1. **Requires config-first workflow** - can't import "blind"
2. **Extra step vs traditional providers** - but this is unavoidable given architecture
3. **Import ID doesn't include cluster info** - relies on config connection

### üîÑ Alternative UX Flow
For convenience, we may add environment variable fallback in future:
```bash
KUBECONFIG=~/.kube/config terraform import k8sinline_manifest.nginx "default/Pod/nginx"
```

## Documentation Impact

### README.md Updates Needed
- Add import section with examples
- Explain config-first requirement  
- Show import ID format
- Common troubleshooting

### Error Messages
- Clear error when config missing: *"Resource configuration with cluster_connection required before import"*
- Helpful import ID format hints: *"Expected format: &lt;namespace&gt;/&lt;kind&gt;/&lt;name&gt;"*

## Testing Strategy

1. **Unit tests** for import ID parsing
2. **Acceptance tests** with live cluster:
   - Import Pod, Service, Deployment, Namespace
   - Import with different connection modes
   - Error cases (invalid ID, missing config, connection failures)

## Future Considerations

- **Multi-cluster imports** - import from one cluster, apply to another
- **Bulk import tooling** - external tools to generate import commands
- **Import validation** - warn if imported YAML differs significantly from config

---

**This ADR establishes k8sinline's import strategy as fundamentally different from traditional providers, but necessarily so given our architecture.**

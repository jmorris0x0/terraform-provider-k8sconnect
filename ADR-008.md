# ADR-008: Environment Variable Import Strategy for k8sinline

**Status:** Accepted  
**Date:** 2025-05-25  
**Authors:** k8sinline team

## Context

The k8sinline provider stores cluster connection information **inline within each resource** rather than at the provider level. This creates a fundamental challenge for Terraform's `import` command:

### The Problem
```bash
# This cannot work - no connection info available during import!
terraform import k8sinline_manifest.example "default/Pod/my-pod"
```

**Root cause:** During import, Terraform calls `ImportState()` before the resource configuration is available. The provider has no way to know:
- Which cluster to connect to
- What credentials to use  
- How to authenticate

### Alternative Approaches Considered

#### 1. **Config-First Import**
Require users to write resource configuration before importing.

**‚ùå Rejected:** Breaks standard Terraform import UX, which would kill adoption.

#### 2. **Provider-Level Connection Fallback**
```hcl
provider "k8sinline" {
  # Fallback connection for imports only
  default_connection {
    kubeconfig_file = "~/.kube/config"
  }
}
```
**‚ùå Rejected:** Violates k8sinline's core design principle of per-resource connections.

#### 3. **Connection String in Import ID**
```bash
terraform import k8sinline_manifest.nginx "host=https://api.cluster.com;ns=default;kind=Pod;name=nginx"
```
**‚ùå Rejected:** Extremely verbose; sensitive credentials in CLI history; poor UX.

## Decision

**Implement Environment Variable Import Strategy:**

1. **Import uses KUBECONFIG environment variable** for cluster connection
2. **Import ID contains context** along with resource coordinates  
3. **Standard Terraform import UX** is preserved
4. **Normal operations use per-resource connections** as designed

## Implementation

### Import Command Pattern
```bash
KUBECONFIG=~/.kube/config terraform import k8sinline_manifest.nginx "prod/default/Pod/nginx"
```

### Import ID Format

**Namespaced resources:** `<context>/<namespace>/<kind>/<name>`
**Cluster-scoped resources:** `<context>/<kind>/<name>`

**Examples:**
- `prod/default/Pod/nginx-abc123` - Pod in default namespace, prod context
- `staging/kube-system/Service/coredns` - Service in kube-system namespace, staging context  
- `prod/Namespace/my-namespace` - Namespace (cluster-scoped), prod context
- `dev/ClusterRole/admin` - ClusterRole (cluster-scoped), dev context

### Import Logic
```go
func (r *manifestResource) ImportState(ctx context.Context, req resource.ImportStateRequest, resp *resource.ImportStateResponse) {
    // 1. Parse import ID: "<context>/<namespace>/<kind>/<name>" or "<context>/<kind>/<name>"
    context, namespace, kind, name, err := r.parseImportID(req.ID)
    if err != nil {
        resp.Diagnostics.AddError("Invalid Import ID", 
            "Expected format: <context>/<namespace>/<kind>/<name> or <context>/<kind>/<name>")
        return
    }
    
    // 2. Read kubeconfig from KUBECONFIG env var
    kubeconfigPath := os.Getenv("KUBECONFIG")
    if kubeconfigPath == "" {
        kubeconfigPath = filepath.Join(os.Getenv("HOME"), ".kube", "config")
    }
    
    // 3. Create K8s client with specified context
    client, err := k8sclient.NewDynamicK8sClientFromKubeconfigFile(kubeconfigPath, context)
    if err != nil {
        resp.Diagnostics.AddError("Connection Failed", err.Error())
        return
    }
    
    // 4. Discover GVR and fetch live object
    gvr, liveObj, err := client.GetGVRFromKind(ctx, kind, namespace, name)
    if err != nil {
        resp.Diagnostics.AddError("Import Failed", err.Error())
        return
    }
    
    // 5. Convert to clean YAML and populate state
    yamlBytes, err := r.objectToYAML(liveObj)
    if err != nil {
        resp.Diagnostics.AddError("YAML Conversion Failed", err.Error())
        return
    }
    
    // 6. Generate resource ID and set state
    resourceID := r.generateIDFromImport(liveObj, context)
    
    importedData := manifestResourceModel{
        ID:       types.StringValue(resourceID),
        YAMLBody: types.StringValue(string(yamlBytes)),
        // cluster_connection will be set by user in their config
        DeleteProtection: types.BoolValue(false), // default
    }
    
    resp.State.Set(ctx, &importedData)
}

func (r *manifestResource) parseImportID(importID string) (context, namespace, kind, name string, err error) {
    parts := strings.Split(importID, "/")
    
    switch len(parts) {
    case 3:
        // Cluster-scoped: "context/kind/name"
        return parts[0], "", parts[1], parts[2], nil
    case 4:
        // Namespaced: "context/namespace/kind/name"  
        return parts[0], parts[1], parts[2], parts[3], nil
    default:
        return "", "", "", "", fmt.Errorf("expected 3 or 4 parts separated by '/', got %d parts", len(parts))
    }
}
```

### Import Blocks Support

The new Terraform import blocks work seamlessly:

```hcl
resource "k8sinline_manifest" "nginx" {
  yaml_body = "# Will be populated during import"
  
  cluster_connection {
    kubeconfig_file = "~/.kube/config"
    context         = "prod"
  }
}

import {
  to = k8sinline_manifest.nginx
  id = "prod/default/Pod/nginx"
}
```

## Rationale

### ‚úÖ Advantages
1. **Standard Terraform UX** - familiar import command and workflow
2. **No credentials in CLI history** - KUBECONFIG is standard practice
3. **Works with all kubeconfig features** - exec auth, multiple contexts, etc.
4. **Clean import IDs** - context included but still readable
5. **Compatible with import blocks** - works with both CLI and declarative imports
6. **One-time compromise** - only import uses env vars, normal ops use per-resource connections
7. **Familiar to Kubernetes users** - KUBECONFIG is universally understood

### ‚ö†Ô∏è Trade-offs  
1. **Import connection differs from runtime connection** - acceptable for one-time operation
2. **Requires KUBECONFIG setup** - standard requirement for Kubernetes tooling
3. **Context must be explicit** - prevents ambiguity but requires users to know context names

### üîÑ Post-Import Workflow
After import, users configure their preferred connection method:

```hcl
resource "k8sinline_manifest" "nginx" {
  yaml_body = "# Populated by import"
  
  # User chooses their preferred connection for normal operations
  cluster_connection {
    host                   = var.cluster_endpoint
    cluster_ca_certificate = var.cluster_ca
    exec = {
      api_version = "client.authentication.k8s.io/v1"
      command     = "aws"
      args        = ["eks", "get-token", "--cluster-name", "prod"]
    }
  }
}
```

## Documentation Impact

### README.md Updates Needed
- Add import section with KUBECONFIG examples
- Explain import ID format with context examples
- Show both CLI import and import blocks usage
- Document KUBECONFIG environment variable requirement

### Error Messages
- Clear error when KUBECONFIG not found: *"KUBECONFIG environment variable or ~/.kube/config file required for import"*
- Helpful import ID format hints: *"Expected format: &lt;context&gt;/&lt;namespace&gt;/&lt;kind&gt;/&lt;name&gt; or &lt;context&gt;/&lt;kind&gt;/&lt;name&gt;"*
- Context validation: *"Context 'prod' not found in kubeconfig"*

## Testing Strategy

1. **Unit tests** for import ID parsing (3-part vs 4-part)
2. **Acceptance tests** with live cluster:
   - Import namespaced resources (Pod, Service, Deployment)
   - Import cluster-scoped resources (Namespace, ClusterRole)
   - Import with different contexts
   - Import blocks vs CLI import
   - Error cases (invalid ID, missing context, connection failures)
3. **KUBECONFIG variations**:
   - Default kubeconfig location
   - Custom KUBECONFIG path
   - Multiple contexts in kubeconfig
   - Exec auth in kubeconfig

## Future Considerations

- **Multi-cluster imports** - import from one context, apply to another context
- **Bulk import tooling** - external tools to generate import commands from cluster resources
- **Import validation** - warn if imported YAML differs from what would be generated by current config

## Examples

### CLI Import
```bash
# Set kubeconfig
export KUBECONFIG=~/.kube/config

# Import namespaced resource
terraform import k8sinline_manifest.nginx "prod/default/Pod/nginx-deployment-abc123"

# Import cluster-scoped resource  
terraform import k8sinline_manifest.my_ns "prod/Namespace/my-namespace"
```

### Import Blocks
```hcl
# Namespaced resource
import {
  to = k8sinline_manifest.nginx  
  id = "prod/default/Pod/nginx-deployment-abc123"
}

# Cluster-scoped resource
import {
  to = k8sinline_manifest.my_ns
  id = "prod/Namespace/my-namespace"  
}
```

---

**This ADR establishes k8sinline's import strategy as using standard Terraform UX while maintaining architectural consistency through environment variables and context-aware import IDs.**


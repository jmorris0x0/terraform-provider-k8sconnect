---
page_title: "Data Source k8sconnect_yaml_scoped - terraform-provider-k8sconnect"
subcategory: ""
description: |-
  Splits multi-document YAML content into categorized manifests for dependency ordering. Resources are grouped by scope: CRDs first, then cluster-scoped resources (Namespaces, ClusterRoles), then namespaced resources (Deployments, Services, etc.).
---

# Data Source: k8sconnect_yaml_scoped

Splits multi-document YAML content into categorized manifests for dependency ordering. Resources are grouped by scope: CRDs first, then cluster-scoped resources (Namespaces, ClusterRoles), then namespaced resources (Deployments, Services, etc.).

## Why yaml_scoped?

Terraform applies resources in parallel batches of ~10. When you apply a large manifest set with `yaml_split` and `for_each`, Terraform may try to create a Deployment before its Namespace exists, or a custom resource before its CRD is registered. Even with k8sconnect's built-in retry logic, this creates unnecessary churn and slower applies.

`yaml_scoped` solves this by automatically categorizing resources into three dependency tiers: CRDs first, then cluster-scoped resources (Namespaces, ClusterRoles), then namespaced resources. With explicit `depends_on` between tiers, Terraform applies each group completely before moving to the next.

Use `yaml_split` for small manifest sets where ordering doesn't matter. Use `yaml_scoped` when you have CRDs, namespaces, and workloads that must apply in order, or when your manifest set is large enough that Terraform's parallelism creates race conditions.

## Example Usage - Dependency Ordering

Use this datasource to ensure proper dependency ordering when applying manifests that include CRDs and custom resources:

```terraform
data "k8sconnect_yaml_scoped" "all" {
  content = file("${path.module}/manifests.yaml")
}

# Apply CRDs first - must exist before custom resources can be created
resource "k8sconnect_object" "crds" {
  for_each = data.k8sconnect_yaml_scoped.all.crds

  yaml_body          = each.value
  cluster = local.cluster
}

# Apply cluster-scoped resources second (Namespaces, ClusterRoles, etc.)
resource "k8sconnect_object" "cluster_scoped" {
  for_each = data.k8sconnect_yaml_scoped.all.cluster_scoped

  yaml_body          = each.value
  cluster = local.cluster

  depends_on = [k8sconnect_object.crds]
}

# Apply namespaced resources last (Deployments, Services, ConfigMaps, Custom Resources, etc.)
resource "k8sconnect_object" "namespaced" {
  for_each = data.k8sconnect_yaml_scoped.all.namespaced

  yaml_body          = each.value
  cluster = local.cluster

  depends_on = [
    k8sconnect_object.crds,
    k8sconnect_object.cluster_scoped
  ]
}
```

## Example Usage - Kustomize with Dependency Ordering

The `kustomize_path` option works seamlessly with scoped categorization:

```terraform
# Build kustomization and categorize by scope
data "k8sconnect_yaml_scoped" "app" {
  kustomize_path = "${path.module}/kustomize/overlays/production"
}

# Apply CRDs first
resource "k8sconnect_object" "crds" {
  for_each = data.k8sconnect_yaml_scoped.app.crds

  yaml_body = each.value
  cluster   = local.cluster
}

# Then cluster-scoped resources
resource "k8sconnect_object" "cluster_scoped" {
  for_each = data.k8sconnect_yaml_scoped.app.cluster_scoped

  yaml_body  = each.value
  cluster    = local.cluster
  depends_on = [k8sconnect_object.crds]
}

# Finally namespaced resources
resource "k8sconnect_object" "namespaced" {
  for_each = data.k8sconnect_yaml_scoped.app.namespaced

  yaml_body  = each.value
  cluster    = local.cluster
  depends_on = [k8sconnect_object.cluster_scoped]
}
```

This combines kustomize's template-free configuration management with automatic dependency ordering based on Kubernetes resource scope.

## Resource Categories

Resources are automatically categorized into three groups:

1. **CRDs** (`crds` output) - CustomResourceDefinitions that must be applied first
2. **Cluster-scoped** (`cluster_scoped` output) - Namespaces, ClusterRoles, PersistentVolumes, etc.
3. **Namespaced** (`namespaced` output) - Deployments, Services, ConfigMaps, and custom resources

<!-- schema generated by tfplugindocs -->
## Schema

### Optional

- `content` (String) Raw YAML content containing one or more Kubernetes manifests separated by '---'. Mutually exclusive with 'pattern' and 'kustomize_path'.
- `kustomize_path` (String) Path to a kustomization directory (containing kustomization.yaml). Runs 'kustomize build' and parses the output. Mutually exclusive with 'content' and 'pattern'.
- `pattern` (String) Glob pattern to match YAML files (e.g., './manifests/*.yaml', './configs/**/*.yml'). Supports recursive patterns. Mutually exclusive with 'content' and 'kustomize_path'.

### Read-Only

- `cluster_scoped` (Map of String) Map of cluster-scoped resource manifests (Namespaces, ClusterRoles, PersistentVolumes, etc). Apply these second after CRDs.
- `crds` (Map of String) Map of CustomResourceDefinition manifests. Apply these first with depends_on to ensure CRDs exist before custom resources.
- `id` (String) Data source identifier based on input content hash.
- `namespaced` (Map of String) Map of namespaced resource manifests (Deployments, Services, ConfigMaps, etc). Apply these last after cluster-scoped resources.

---
page_title: "{{.Type}} {{.Name}} - {{.ProviderName}}"
subcategory: ""
description: |-
{{ .Description | plainmarkdown | trimspace | prefixlines "  " }}
---

# {{.Type}}: {{.Name}}

{{ .Description | trimspace }}

## Why yaml_scoped?

Terraform applies resources in parallel batches of ~10. When you apply a large manifest set with `yaml_split` and `for_each`, Terraform may try to create a Deployment before its Namespace exists, or a custom resource before its CRD is registered. Even with k8sconnect's built-in retry logic, this creates unnecessary churn and slower applies.

`yaml_scoped` solves this by automatically categorizing resources into three dependency tiers: CRDs first, then cluster-scoped resources (Namespaces, ClusterRoles), then namespaced resources. With explicit `depends_on` between tiers, Terraform applies each group completely before moving to the next.

Use `yaml_split` for small manifest sets where ordering doesn't matter. Use `yaml_scoped` when you have CRDs, namespaces, and workloads that must apply in order, or when your manifest set is large enough that Terraform's parallelism creates race conditions.

## Example Usage - Dependency Ordering

Use this datasource to ensure proper dependency ordering when applying manifests that include CRDs and custom resources:

```terraform
data "k8sconnect_yaml_scoped" "all" {
  content = file("${path.module}/manifests.yaml")
}

# Apply CRDs first - must exist before custom resources can be created
resource "k8sconnect_object" "crds" {
  for_each = data.k8sconnect_yaml_scoped.all.crds

  yaml_body          = each.value
  cluster = local.cluster
}

# Apply cluster-scoped resources second (Namespaces, ClusterRoles, etc.)
resource "k8sconnect_object" "cluster_scoped" {
  for_each = data.k8sconnect_yaml_scoped.all.cluster_scoped

  yaml_body          = each.value
  cluster = local.cluster

  depends_on = [k8sconnect_object.crds]
}

# Apply namespaced resources last (Deployments, Services, ConfigMaps, Custom Resources, etc.)
resource "k8sconnect_object" "namespaced" {
  for_each = data.k8sconnect_yaml_scoped.all.namespaced

  yaml_body          = each.value
  cluster = local.cluster

  depends_on = [
    k8sconnect_object.crds,
    k8sconnect_object.cluster_scoped
  ]
}
```

## Example Usage - Kustomize with Dependency Ordering

The `kustomize_path` option works seamlessly with scoped categorization:

```terraform
# Build kustomization and categorize by scope
data "k8sconnect_yaml_scoped" "app" {
  kustomize_path = "${path.module}/kustomize/overlays/production"
}

# Apply CRDs first
resource "k8sconnect_object" "crds" {
  for_each = data.k8sconnect_yaml_scoped.app.crds

  yaml_body = each.value
  cluster   = local.cluster
}

# Then cluster-scoped resources
resource "k8sconnect_object" "cluster_scoped" {
  for_each = data.k8sconnect_yaml_scoped.app.cluster_scoped

  yaml_body  = each.value
  cluster    = local.cluster
  depends_on = [k8sconnect_object.crds]
}

# Finally namespaced resources
resource "k8sconnect_object" "namespaced" {
  for_each = data.k8sconnect_yaml_scoped.app.namespaced

  yaml_body  = each.value
  cluster    = local.cluster
  depends_on = [k8sconnect_object.cluster_scoped]
}
```

This combines kustomize's template-free configuration management with automatic dependency ordering based on Kubernetes resource scope.

## Resource Categories

Resources are automatically categorized into three groups:

1. **CRDs** (`crds` output) - CustomResourceDefinitions that must be applied first
2. **Cluster-scoped** (`cluster_scoped` output) - Namespaces, ClusterRoles, PersistentVolumes, etc.
3. **Namespaced** (`namespaced` output) - Deployments, Services, ConfigMaps, and custom resources

{{ .SchemaMarkdown | trimspace }}

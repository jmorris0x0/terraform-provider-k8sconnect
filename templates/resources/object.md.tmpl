---
page_title: "{{.Type}} {{.Name}} - {{.ProviderName}}"
subcategory: ""
description: |-
{{ .Description | plainmarkdown | trimspace | prefixlines "  " }}
---

# {{.Type}}: {{.Name}}

{{ .Description | trimspace }}

## Example Usage - Basic Deployment

<!-- runnable-test: object-basic-deployment -->
```terraform
resource "k8sconnect_object" "namespace" {
  yaml_body = <<-YAML
    apiVersion: v1
    kind: Namespace
    metadata:
      name: example
  YAML

  cluster_connection = var.cluster_connection
}

resource "k8sconnect_object" "deployment" {
  yaml_body = <<-YAML
    apiVersion: apps/v1
    kind: Deployment
    metadata:
      name: nginx
      namespace: example
    spec:
      replicas: 2
      selector:
        matchLabels:
          app: nginx
      template:
        metadata:
          labels:
            app: nginx
        spec:
          containers:
          - name: nginx
            image: nginx:1.21
  YAML

  cluster_connection = var.cluster_connection
  depends_on         = [k8sconnect_object.namespace]
}
```
<!-- /runnable-test -->

## Example Usage - Bootstrap EKS Cluster with Workloads

Single terraform apply to create cluster and deploy workloads:

```terraform
resource "aws_eks_cluster" "main" {
  name     = "my-cluster"
  role_arn = aws_iam_role.cluster.arn
  # ... cluster configuration
}

resource "k8sconnect_object" "cert_manager" {
  yaml_body = file("cert-manager.yaml")

  cluster_connection = {
    host                   = aws_eks_cluster.main.endpoint
    cluster_ca_certificate = base64decode(aws_eks_cluster.main.certificate_authority[0].data)
    exec = {
      api_version = "client.authentication.k8s.io/v1"
      command     = "aws"
      args        = ["eks", "get-token", "--cluster-name", aws_eks_cluster.main.name]
    }
  }
}
```

## Example Usage - Coexisting with HPA

Use `ignore_fields` to let the HorizontalPodAutoscaler manage replicas:

<!-- runnable-test: object-hpa-coexistence -->
```terraform
resource "k8sconnect_object" "app" {
  yaml_body = <<-YAML
    apiVersion: apps/v1
    kind: Deployment
    metadata:
      name: nginx-with-hpa
      namespace: example
    spec:
      replicas: 2
      selector:
        matchLabels:
          app: nginx
      template:
        metadata:
          labels:
            app: nginx
        spec:
          containers:
          - name: nginx
            image: nginx:1.21
            resources:
              requests:
                cpu: 100m
  YAML

  # Ignore spec.replicas because HPA will modify it
  ignore_fields = ["spec.replicas"]

  cluster_connection = var.cluster_connection
}

resource "k8sconnect_object" "hpa" {
  yaml_body = <<-YAML
    apiVersion: autoscaling/v2
    kind: HorizontalPodAutoscaler
    metadata:
      name: nginx-hpa
      namespace: example
    spec:
      scaleTargetRef:
        apiVersion: apps/v1
        kind: Deployment
        name: nginx-with-hpa
      minReplicas: 1
      maxReplicas: 10
      metrics:
      - type: Resource
        resource:
          name: cpu
          target:
            type: Utilization
            averageUtilization: 50
  YAML

  cluster_connection = var.cluster_connection
  depends_on         = [k8sconnect_object.app]
}
```
<!-- /runnable-test -->

## Example Usage - Multi-Cluster Deployment

Deploy the same resource to multiple clusters:

```terraform
locals {
  prod_connection = {
    host                   = aws_eks_cluster.prod.endpoint
    cluster_ca_certificate = base64decode(aws_eks_cluster.prod.certificate_authority[0].data)
    exec = {
      api_version = "client.authentication.k8s.io/v1"
      command     = "aws"
      args        = ["eks", "get-token", "--cluster-name", "prod"]
    }
  }

  staging_connection = {
    kubeconfig = file("~/.kube/staging-config")
    context    = "staging"
  }
}

resource "k8sconnect_object" "prod_app" {
  yaml_body          = file("app.yaml")
  cluster_connection = local.prod_connection
}

resource "k8sconnect_object" "staging_app" {
  yaml_body          = file("app.yaml")
  cluster_connection = local.staging_connection
}
```

{{ .SchemaMarkdown | trimspace }}

{{- if .HasImport }}

## Import

Import existing Kubernetes resources into Terraform management.

### Import Syntax

The import ID format uses colons (`:`) as delimiters:

```shell
# Namespaced resources: context:namespace:apiVersion/Kind:name
# Cluster-scoped resources: context:apiVersion/Kind:name
```

The `apiVersion` is **required** to prevent ambiguity when multiple API versions exist for the same kind.

### Setup

```shell
# Set your kubeconfig
export KUBECONFIG=~/.kube/config
```

### Examples

```shell
# Core resources (namespaced)
terraform import k8sconnect_object.nginx "prod:default:v1/Pod:nginx-abc123"
terraform import k8sconnect_object.config "prod:default:v1/ConfigMap:app-config"
terraform import k8sconnect_object.svc "prod:kube-system:v1/Service:coredns"

# Resources with API groups (namespaced)
terraform import k8sconnect_object.app "prod:default:apps/v1/Deployment:my-app"
terraform import k8sconnect_object.sts "prod:default:apps/v1/StatefulSet:postgres"
terraform import k8sconnect_object.ing "prod:default:networking.k8s.io/v1/Ingress:api-gateway"

# Cluster-scoped resources
terraform import k8sconnect_object.namespace "prod:v1/Namespace:my-namespace"
terraform import k8sconnect_object.reader "prod:rbac.authorization.k8s.io/v1/ClusterRole:pod-reader"

# Custom resources
terraform import k8sconnect_object.cert "prod:default:cert-manager.io/v1/Certificate:my-cert"
terraform import k8sconnect_object.cr "prod:default:stable.example.com/v1/MyResource:instance-1"
```

**Finding the apiVersion:**

If you're unsure of the apiVersion for a resource:

```shell
kubectl get <kind> <name> -o jsonpath='{.apiVersion}'

# Example
kubectl get deployment my-app -n default -o jsonpath='{.apiVersion}'
# Output: apps/v1
```

After import, add the `cluster_connection` block to your configuration to match how you want to connect during normal operations.
{{- end }}

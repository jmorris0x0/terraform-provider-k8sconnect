---
page_title: "{{.Type}} {{.Name}} - {{.ProviderName}}"
subcategory: ""
description: |-
{{ .Description | plainmarkdown | trimspace | prefixlines "  " }}
---

# {{.Type}}: {{.Name}}

{{ .Description | trimspace }}

## Example Usage - Basic Deployment

```terraform
resource "k8sconnect_manifest" "namespace" {
  yaml_body = <<-YAML
    apiVersion: v1
    kind: Namespace
    metadata:
      name: example
  YAML

  cluster_connection = var.cluster_connection
}

resource "k8sconnect_manifest" "deployment" {
  yaml_body = <<-YAML
    apiVersion: apps/v1
    kind: Deployment
    metadata:
      name: nginx
      namespace: example
    spec:
      replicas: 2
      selector:
        matchLabels:
          app: nginx
      template:
        metadata:
          labels:
            app: nginx
        spec:
          containers:
          - name: nginx
            image: nginx:1.21
  YAML

  cluster_connection = var.cluster_connection
  depends_on         = [k8sconnect_manifest.namespace]
}
```

## Example Usage - Bootstrap EKS Cluster with Workloads

Single terraform apply to create cluster and deploy workloads:

```terraform
resource "aws_eks_cluster" "main" {
  name     = "my-cluster"
  role_arn = aws_iam_role.cluster.arn
  # ... cluster configuration
}

resource "k8sconnect_manifest" "cert_manager" {
  yaml_body = file("cert-manager.yaml")

  cluster_connection = {
    host                   = aws_eks_cluster.main.endpoint
    cluster_ca_certificate = base64decode(aws_eks_cluster.main.certificate_authority[0].data)
    exec = {
      api_version = "client.authentication.k8s.io/v1"
      command     = "aws"
      args        = ["eks", "get-token", "--cluster-name", aws_eks_cluster.main.name]
    }
  }
}
```

## Example Usage - Coexisting with HPA

Use `ignore_fields` to let the HorizontalPodAutoscaler manage replicas:

```terraform
resource "k8sconnect_manifest" "app" {
  yaml_body = <<-YAML
    apiVersion: apps/v1
    kind: Deployment
    metadata:
      name: nginx-with-hpa
      namespace: example
    spec:
      replicas: 2
      selector:
        matchLabels:
          app: nginx
      template:
        metadata:
          labels:
            app: nginx
        spec:
          containers:
          - name: nginx
            image: nginx:1.21
            resources:
              requests:
                cpu: 100m
  YAML

  # Ignore spec.replicas because HPA will modify it
  ignore_fields = ["spec.replicas"]

  cluster_connection = var.cluster_connection
}

resource "k8sconnect_manifest" "hpa" {
  yaml_body = <<-YAML
    apiVersion: autoscaling/v2
    kind: HorizontalPodAutoscaler
    metadata:
      name: nginx-hpa
      namespace: example
    spec:
      scaleTargetRef:
        apiVersion: apps/v1
        kind: Deployment
        name: nginx-with-hpa
      minReplicas: 1
      maxReplicas: 10
      metrics:
      - type: Resource
        resource:
          name: cpu
          target:
            type: Utilization
            averageUtilization: 50
  YAML

  cluster_connection = var.cluster_connection
  depends_on         = [k8sconnect_manifest.app]
}
```

## Example Usage - Wait for LoadBalancer and Use Status (field wait)

Wait for a LoadBalancer to be provisioned and use its IP in other resources. **Only `field` waits populate `.status` for chaining.**

```terraform
resource "k8sconnect_manifest" "loadbalancer_service" {
  yaml_body = <<-YAML
    apiVersion: v1
    kind: Service
    metadata:
      name: demo-lb
      namespace: example
    spec:
      type: LoadBalancer
      ports:
      - port: 80
        targetPort: 8080
      selector:
        app: demo
  YAML

  wait_for = {
    field   = "status.loadBalancer.ingress"  # Enables .status output
    timeout = "5m"
  }

  cluster_connection = var.cluster_connection
}

# Use the LoadBalancer IP in another resource
resource "k8sconnect_manifest" "endpoint_config" {
  yaml_body = <<-YAML
    apiVersion: v1
    kind: ConfigMap
    metadata:
      name: external-endpoints
      namespace: example
    data:
      service_endpoint: "${k8sconnect_manifest.loadbalancer_service.status.loadBalancer.ingress[0].ip}:80"
  YAML

  cluster_connection = var.cluster_connection
  depends_on         = [k8sconnect_manifest.loadbalancer_service]
}
```

## Example Usage - Wait for Deployment Rollout (rollout wait)

Wait for a Deployment to fully roll out before continuing:

```terraform
resource "k8sconnect_manifest" "app" {
  yaml_body = <<-YAML
    apiVersion: apps/v1
    kind: Deployment
    metadata:
      name: web-app
      namespace: example
    spec:
      replicas: 3
      selector:
        matchLabels:
          app: web
      template:
        metadata:
          labels:
            app: web
        spec:
          containers:
          - name: nginx
            image: nginx:1.21
            resources:
              requests:
                cpu: 100m
                memory: 128Mi
  YAML

  # Wait for all replicas to be updated and ready
  wait_for = {
    rollout = true
    timeout = "5m"
  }

  cluster_connection = var.cluster_connection
}
```

## Example Usage - Wait for Condition (condition wait)

Wait for a Kubernetes condition to be True:

```terraform
resource "k8sconnect_manifest" "app" {
  yaml_body = <<-YAML
    apiVersion: apps/v1
    kind: Deployment
    metadata:
      name: storage-app
      namespace: example
    spec:
      replicas: 1
      selector:
        matchLabels:
          app: storage
      template:
        metadata:
          labels:
            app: storage
        spec:
          containers:
          - name: app
            image: busybox:latest
            command: ["sh", "-c", "while true; do date; sleep 30; done"]
  YAML

  # Wait for "Available" condition (minimum availability reached)
  wait_for = {
    condition = "Available"
    timeout   = "3m"
  }

  cluster_connection = var.cluster_connection
}
```

## Example Usage - Wait for Field Value (field_value wait)

Wait for specific field values:

```terraform
resource "k8sconnect_manifest" "migration_job" {
  yaml_body = <<-YAML
    apiVersion: batch/v1
    kind: Job
    metadata:
      name: database-migration
      namespace: example
    spec:
      template:
        spec:
          containers:
          - name: migrate
            image: busybox:latest
            command: ["sh", "-c", "echo 'Running migrations...' && sleep 5"]
          restartPolicy: Never
  YAML

  # Wait for exactly 1 successful completion
  wait_for = {
    field_value = {
      "status.succeeded" = "1"
    }
    timeout = "5m"
  }

  cluster_connection = var.cluster_connection
}
```

## Example Usage - Multi-Cluster Deployment

Deploy the same resource to multiple clusters:

```terraform
locals {
  prod_connection = {
    host                   = aws_eks_cluster.prod.endpoint
    cluster_ca_certificate = base64decode(aws_eks_cluster.prod.certificate_authority[0].data)
    exec = {
      api_version = "client.authentication.k8s.io/v1"
      command     = "aws"
      args        = ["eks", "get-token", "--cluster-name", "prod"]
    }
  }

  staging_connection = {
    kubeconfig = file("~/.kube/staging-config")
    context    = "staging"
  }
}

resource "k8sconnect_manifest" "prod_app" {
  yaml_body          = file("app.yaml")
  cluster_connection = local.prod_connection
}

resource "k8sconnect_manifest" "staging_app" {
  yaml_body          = file("app.yaml")
  cluster_connection = local.staging_connection
}
```

{{ .SchemaMarkdown | trimspace }}

{{- if .HasImport }}

## Import

Import existing Kubernetes resources into Terraform management.

### Import Syntax

```shell
# Set your kubeconfig
export KUBECONFIG=~/.kube/config

# Namespaced resources: context/namespace/Kind/name
terraform import k8sconnect_manifest.nginx "prod/default/Pod/nginx-abc123"

# Cluster-scoped resources: context/Kind/name
terraform import k8sconnect_manifest.namespace "prod/Namespace/my-namespace"
```

### Examples

```shell
# Import a Deployment
terraform import k8sconnect_manifest.app "prod/default/Deployment/my-app"

# Import a ConfigMap
terraform import k8sconnect_manifest.config "prod/default/ConfigMap/app-config"

# Import a ClusterRole (cluster-scoped)
terraform import k8sconnect_manifest.reader "prod/ClusterRole/pod-reader"

# Import using specific kubeconfig context
terraform import k8sconnect_manifest.svc "staging-cluster/default/Service/web"
```

After import, add the `cluster_connection` block to your configuration to match how you want to connect during normal operations.
{{- end }}

package object

import (
	"context"

	"github.com/hashicorp/terraform-plugin-framework/resource"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema"

	"github.com/hashicorp/terraform-plugin-framework-validators/listvalidator"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/planmodifier"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/stringplanmodifier"
	"github.com/hashicorp/terraform-plugin-framework/schema/validator"
	"github.com/hashicorp/terraform-plugin-framework/types"

	"github.com/jmorris0x0/terraform-provider-k8sconnect/internal/k8sconnect/common/auth"
	"github.com/jmorris0x0/terraform-provider-k8sconnect/internal/k8sconnect/common/factory"
	"github.com/jmorris0x0/terraform-provider-k8sconnect/internal/k8sconnect/common/k8sclient"
)

var _ resource.Resource = (*objectResource)(nil)
var _ resource.ResourceWithConfigValidators = (*objectResource)(nil)
var _ resource.ResourceWithModifyPlan = (*objectResource)(nil)
var _ resource.ResourceWithImportState = (*objectResource)(nil)
var _ resource.ResourceWithConfigure = (*objectResource)(nil)

// Private state keys
const (
	privateStateKeyOwnership = "field_ownership_v1"
)

// ClientGetter function type for dependency injection
type ClientGetter func(auth.ClusterModel) (k8sclient.K8sClient, error)

type objectResource struct {
	clientGetter  ClientGetter // Keep for now
	clientFactory factory.ClientFactory
}

type objectResourceModel struct {
	ID                     types.String `tfsdk:"id"`
	YAMLBody               types.String `tfsdk:"yaml_body"`
	Cluster                types.Object `tfsdk:"cluster"`
	DeleteProtection       types.Bool   `tfsdk:"delete_protection"`
	DeleteTimeout          types.String `tfsdk:"delete_timeout"`
	ForceDestroy           types.Bool   `tfsdk:"force_destroy"`
	IgnoreFields           types.List   `tfsdk:"ignore_fields"`
	ManagedStateProjection types.Map    `tfsdk:"managed_state_projection"`
	ObjectRef              types.Object `tfsdk:"object_ref"`
}

type objectRefModel struct {
	APIVersion types.String `tfsdk:"api_version"`
	Kind       types.String `tfsdk:"kind"`
	Name       types.String `tfsdk:"name"`
	Namespace  types.String `tfsdk:"namespace"`
}

// Creates a object resource with custom client getter
func NewObjectResourceWithClientGetter(getter ClientGetter) resource.Resource {
	return &objectResource{
		clientGetter: getter,
	}
}

func (r *objectResource) Metadata(ctx context.Context, req resource.MetadataRequest, resp *resource.MetadataResponse) {
	resp.TypeName = req.ProviderTypeName + "_object"
}

func (r *objectResource) Configure(ctx context.Context, req resource.ConfigureRequest, resp *resource.ConfigureResponse) {
	// Skip if provider data is not available (e.g., during planning)
	if req.ProviderData == nil {
		return
	}

	// Try to get client factory directly (no more ConnectionConfig)
	clientFactory, ok := req.ProviderData.(factory.ClientFactory)
	if !ok {
		resp.Diagnostics.AddError(
			"Unexpected Provider Data Type",
			"Expected factory.ClientFactory but got something else. This is a provider bug.",
		)
		return
	}

	// Store the client factory
	r.clientFactory = clientFactory

	// For backward compatibility, create a clientGetter that uses the factory
	r.clientGetter = func(conn auth.ClusterModel) (k8sclient.K8sClient, error) {
		return r.clientFactory.GetClient(conn)
	}
}

func (r *objectResource) Schema(ctx context.Context, req resource.SchemaRequest, resp *resource.SchemaResponse) {
	resp.Schema = schema.Schema{
		Description: "Applies a single‑document Kubernetes YAML manifest to a cluster, with per‑resource inline or kubeconfig‑based connection settings.",
		Attributes: map[string]schema.Attribute{
			"id": schema.StringAttribute{
				Computed: true,
				PlanModifiers: []planmodifier.String{
					stringplanmodifier.UseStateForUnknown(),
				},
				Description: "Unique identifier for this manifest (generated by the provider).",
			},
			"yaml_body": schema.StringAttribute{
				Required:    true,
				Description: "UTF-8 encoded, single-document Kubernetes YAML. Multi-doc files will fail validation.",
				Validators: []validator.String{
					yamlValidator{singleDoc: true},
					serverManagedFieldsValidator{},
				},
			},
			"cluster": schema.SingleNestedAttribute{
				Required: true,
				Description: "Kubernetes cluster connection for this specific resource. Can be different per-resource, enabling multi-cluster " +
					"deployments without provider aliases. Supports inline credentials (token, exec, client certs) or kubeconfig.",
				Attributes: auth.GetConnectionSchemaForResource(),
			},
			"delete_protection": schema.BoolAttribute{
				Optional:    true,
				Description: "Prevent accidental deletion of the resource. If set to true, the resource cannot be deleted unless this field is set to false.",
			},
			"delete_timeout": schema.StringAttribute{
				Optional:    true,
				Description: "How long to wait for a resource to be deleted before considering the deletion failed. Defaults to 300s (5 minutes).",
				Validators: []validator.String{
					durationValidator{},
				},
			},
			"force_destroy": schema.BoolAttribute{
				Optional:            true,
				MarkdownDescription: `Force deletion by removing finalizers. **WARNING:** Unlike other providers, this REMOVES finalizers after timeout. May cause data loss and orphaned cloud resources. Consult documentation before enabling.`,
			},
			"managed_state_projection": schema.MapAttribute{
				Computed:    true,
				ElementType: types.StringType,
				Description: "Field-by-field snapshot of managed state as flat key-value pairs with dotted paths. " +
					"Shows exactly which fields k8sconnect manages and their current values. " +
					"Terraform automatically displays only changed keys in diffs for clean, scannable output. " +
					"When this differs from current cluster state, it indicates drift - someone modified your managed fields outside Terraform. " +
					"Computed via Server-Side Apply dry-run for accuracy, enabling precise drift detection without false positives.",
			},
			"ignore_fields": schema.ListAttribute{
				Optional:    true,
				ElementType: types.StringType,
				Description: "Field paths to exclude from management using JSONPath syntax. Use for fields controlled by other systems " +
					"(HPA replicas, cert-manager CA bundles, operator annotations). " +
					"Supports dot notation ('spec.replicas'), positional arrays ('webhooks[0].caBundle'), " +
					"and JSONPath predicates ('containers[?(@.name==\"nginx\")].image'). " +
					"Example: 'spec.template.spec.containers[?(@.name==\"app\")].env[?(@.name==\"EXTERNAL_VAR\")].value'",
				Validators: []validator.List{
					listvalidator.ValueStringsAre(ignoreFieldsValidator{}),
				},
			},
			"object_ref": schema.SingleNestedAttribute{
				Computed: true,
				Description: "Kubernetes object reference containing the identity of the applied resource. " +
					"Populated after successful apply. Used by k8sconnect_wait resource to locate the object for waiting. " +
					"Contains api_version, kind, name, and namespace (if namespaced).",
				Attributes: map[string]schema.Attribute{
					"api_version": schema.StringAttribute{
						Computed:    true,
						Description: "Kubernetes API version (e.g., 'v1', 'apps/v1')",
					},
					"kind": schema.StringAttribute{
						Computed:    true,
						Description: "Kubernetes resource kind (e.g., 'Pod', 'Deployment')",
					},
					"name": schema.StringAttribute{
						Computed:    true,
						Description: "Resource name from metadata.name",
					},
					"namespace": schema.StringAttribute{
						Computed:    true,
						Description: "Resource namespace from metadata.namespace. Null for cluster-scoped resources.",
					},
				},
			},
		},
	}
}

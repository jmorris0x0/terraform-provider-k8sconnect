package helm_release

import (
	"context"

	"github.com/hashicorp/terraform-plugin-framework/resource"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/booldefault"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/planmodifier"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/stringdefault"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/stringplanmodifier"
	"github.com/hashicorp/terraform-plugin-framework/types"

	"github.com/jmorris0x0/terraform-provider-k8sconnect/internal/k8sconnect/common/auth"
	"github.com/jmorris0x0/terraform-provider-k8sconnect/internal/k8sconnect/common/factory"
)

var _ resource.Resource = (*helmReleaseResource)(nil)
var _ resource.ResourceWithConfigure = (*helmReleaseResource)(nil)
var _ resource.ResourceWithImportState = (*helmReleaseResource)(nil)

type helmReleaseResource struct {
	clientFactory factory.ClientFactory
}

type helmReleaseResourceModel struct {
	ID        types.String `tfsdk:"id"`
	Name      types.String `tfsdk:"name"`
	Namespace types.String `tfsdk:"namespace"`

	// Chart source
	Repository types.String `tfsdk:"repository"`
	Chart      types.String `tfsdk:"chart"`
	Version    types.String `tfsdk:"version"`

	// Values
	Values       types.String `tfsdk:"values"`
	Set          types.List   `tfsdk:"set"`
	SetSensitive types.List   `tfsdk:"set_sensitive"`
	SetList      types.List   `tfsdk:"set_list"`
	SetString    types.List   `tfsdk:"set_string"`

	// Cluster configuration (THE KEY FEATURE)
	Cluster types.Object `tfsdk:"cluster"`

	// Repository authentication
	RepositoryUsername types.String `tfsdk:"repository_username"`
	RepositoryPassword types.String `tfsdk:"repository_password"`
	RepositoryKeyFile  types.String `tfsdk:"repository_key_file"`
	RepositoryCertFile types.String `tfsdk:"repository_cert_file"`
	RepositoryCaFile   types.String `tfsdk:"repository_ca_file"`

	// Helm release options
	CreateNamespace  types.Bool   `tfsdk:"create_namespace"`
	DependencyUpdate types.Bool   `tfsdk:"dependency_update"`
	SkipCRDs         types.Bool   `tfsdk:"skip_crds"`
	Atomic           types.Bool   `tfsdk:"atomic"`
	Wait             types.Bool   `tfsdk:"wait"`
	WaitForJobs      types.Bool   `tfsdk:"wait_for_jobs"`
	Timeout          types.String `tfsdk:"timeout"`
	DisableWebhooks  types.Bool   `tfsdk:"disable_webhooks"`
	RecreatePods     types.Bool   `tfsdk:"recreate_pods"`
	ForceDestroy     types.Bool   `tfsdk:"force_destroy"`

	// Computed outputs
	Manifest types.String `tfsdk:"manifest"`
	Status   types.String `tfsdk:"status"`
	Revision types.Int64  `tfsdk:"revision"`
	Metadata types.Map    `tfsdk:"metadata"`
}

type setValueModel struct {
	Name  types.String `tfsdk:"name"`
	Value types.String `tfsdk:"value"`
}

func NewHelmReleaseResource() resource.Resource {
	return &helmReleaseResource{}
}

func (r *helmReleaseResource) Metadata(ctx context.Context, req resource.MetadataRequest, resp *resource.MetadataResponse) {
	resp.TypeName = req.ProviderTypeName + "_helm_release"
}

func (r *helmReleaseResource) Configure(ctx context.Context, req resource.ConfigureRequest, resp *resource.ConfigureResponse) {
	if req.ProviderData == nil {
		return
	}

	clientFactory, ok := req.ProviderData.(factory.ClientFactory)
	if !ok {
		resp.Diagnostics.AddError(
			"Unexpected Provider Data Type",
			"Expected factory.ClientFactory but got something else. This is a provider bug.",
		)
		return
	}

	r.clientFactory = clientFactory
}

func (r *helmReleaseResource) Schema(ctx context.Context, req resource.SchemaRequest, resp *resource.SchemaResponse) {
	resp.Schema = schema.Schema{
		Version:     1,
		Description: "Manages a Helm release with inline cluster configuration, enabling single-apply cluster bootstrapping. This is a full Helm release (not just templating) - hooks execute, release history is maintained, and helm CLI commands work.",
		Attributes: map[string]schema.Attribute{
			"id": schema.StringAttribute{
				Computed: true,
				PlanModifiers: []planmodifier.String{
					stringplanmodifier.UseStateForUnknown(),
				},
				Description: "Unique identifier for this Helm release (generated by the provider).",
			},
			"name": schema.StringAttribute{
				Required:    true,
				Description: "Release name. Must be unique within the namespace.",
				PlanModifiers: []planmodifier.String{
					stringplanmodifier.RequiresReplace(),
				},
			},
			"namespace": schema.StringAttribute{
				Optional:    true,
				Computed:    true,
				Default:     stringdefault.StaticString("default"),
				Description: "Namespace to install the release into. Defaults to 'default'.",
				PlanModifiers: []planmodifier.String{
					stringplanmodifier.RequiresReplace(),
				},
			},
			"repository": schema.StringAttribute{
				Optional:    true,
				Description: "Helm repository URL (e.g., 'https://helm.cilium.io/') or OCI registry (e.g., 'oci://registry.example.com/charts'). Leave empty for local charts.",
			},
			"chart": schema.StringAttribute{
				Required:    true,
				Description: "Chart name or path. For repository charts, use the chart name. For local charts, use the path to the chart directory.",
			},
			"version": schema.StringAttribute{
				Optional:    true,
				Description: "Chart version. Can include digest for OCI charts (e.g., '1.0.0@sha256:...'). If not specified, uses the latest version.",
			},
			"values": schema.StringAttribute{
				Optional:    true,
				Description: "Values in YAML format to merge with chart defaults. Typically used with file() function.",
				Sensitive:   true,
			},
			"set": schema.ListNestedAttribute{
				Optional:    true,
				Description: "Set individual values. Has higher precedence than 'values' file.",
				NestedObject: schema.NestedAttributeObject{
					Attributes: map[string]schema.Attribute{
						"name": schema.StringAttribute{
							Required:    true,
							Description: "Value name (can use dot notation for nested values, e.g., 'image.tag').",
						},
						"value": schema.StringAttribute{
							Required:    true,
							Description: "Value to set.",
						},
					},
				},
			},
			"set_sensitive": schema.ListNestedAttribute{
				Optional:    true,
				Description: "Set individual sensitive values (passwords, tokens, etc.). Has highest precedence.",
				NestedObject: schema.NestedAttributeObject{
					Attributes: map[string]schema.Attribute{
						"name": schema.StringAttribute{
							Required:    true,
							Description: "Value name (can use dot notation for nested values).",
						},
						"value": schema.StringAttribute{
							Required:    true,
							Sensitive:   true,
							Description: "Sensitive value to set.",
						},
					},
				},
			},
			"set_list": schema.ListNestedAttribute{
				Optional:    true,
				Description: "Set list values (e.g., 'ingress.hosts[0]=example.com').",
				NestedObject: schema.NestedAttributeObject{
					Attributes: map[string]schema.Attribute{
						"name": schema.StringAttribute{
							Required:    true,
							Description: "List value name.",
						},
						"value": schema.StringAttribute{
							Required:    true,
							Description: "List value to set.",
						},
					},
				},
			},
			"set_string": schema.ListNestedAttribute{
				Optional:    true,
				Description: "Set string values (forces value to be treated as string).",
				NestedObject: schema.NestedAttributeObject{
					Attributes: map[string]schema.Attribute{
						"name": schema.StringAttribute{
							Required:    true,
							Description: "Value name.",
						},
						"value": schema.StringAttribute{
							Required:    true,
							Description: "String value to set.",
						},
					},
				},
			},
			"cluster": schema.SingleNestedAttribute{
				Required:    true,
				Description: "Cluster connection configuration. Unlike hashicorp/helm provider, this is specified per-resource, enabling bootstrapping scenarios.",
				Attributes:  auth.GetConnectionSchemaForResource(),
			},
			"repository_username": schema.StringAttribute{
				Optional:    true,
				Description: "Username for chart repository authentication.",
			},
			"repository_password": schema.StringAttribute{
				Optional:    true,
				Sensitive:   true,
				Description: "Password for chart repository authentication.",
			},
			"repository_key_file": schema.StringAttribute{
				Optional:    true,
				Description: "Path to key file for TLS client authentication to chart repository.",
			},
			"repository_cert_file": schema.StringAttribute{
				Optional:    true,
				Description: "Path to certificate file for TLS client authentication to chart repository.",
			},
			"repository_ca_file": schema.StringAttribute{
				Optional:    true,
				Description: "Path to CA bundle to verify chart repository certificates.",
			},
			"create_namespace": schema.BoolAttribute{
				Optional:    true,
				Computed:    true,
				Default:     booldefault.StaticBool(false),
				Description: "Create the namespace if it does not exist. Defaults to false.",
			},
			"dependency_update": schema.BoolAttribute{
				Optional:    true,
				Computed:    true,
				Default:     booldefault.StaticBool(false),
				Description: "Run 'helm dependency update' before installing the chart. Defaults to false.",
			},
			"skip_crds": schema.BoolAttribute{
				Optional:    true,
				Computed:    true,
				Default:     booldefault.StaticBool(false),
				Description: "Skip installing CRDs. Defaults to false.",
			},
			"atomic": schema.BoolAttribute{
				Optional:    true,
				Computed:    true,
				Default:     booldefault.StaticBool(false),
				Description: "If true, installation/upgrade process rolls back changes on failure. Defaults to false.",
			},
			"wait": schema.BoolAttribute{
				Optional:    true,
				Computed:    true,
				Default:     booldefault.StaticBool(true),
				Description: "Wait for all resources to be ready before marking the release as successful. Defaults to true. Unlike hashicorp/helm, this waits for ALL workload types including DaemonSets.",
			},
			"wait_for_jobs": schema.BoolAttribute{
				Optional:    true,
				Computed:    true,
				Default:     booldefault.StaticBool(false),
				Description: "Wait for Jobs to complete before marking the release as successful. Defaults to false.",
			},
			"timeout": schema.StringAttribute{
				Optional:    true,
				Computed:    true,
				Default:     stringdefault.StaticString("300s"),
				Description: "Time to wait for operations to complete. Format: '300s', '5m', '1h'. Defaults to '300s'.",
			},
			"disable_webhooks": schema.BoolAttribute{
				Optional:    true,
				Computed:    true,
				Default:     booldefault.StaticBool(false),
				Description: "Prevent Helm from running validation webhooks. Defaults to false.",
			},
			"recreate_pods": schema.BoolAttribute{
				Optional:    true,
				Computed:    true,
				Default:     booldefault.StaticBool(false),
				Description: "Perform pod restart during upgrade/rollback. Defaults to false.",
			},
			"force_destroy": schema.BoolAttribute{
				Optional:    true,
				Computed:    true,
				Default:     booldefault.StaticBool(false),
				Description: "Allow deletion even if resources have finalizers or delete protection. Use with caution. Defaults to false.",
			},
			"manifest": schema.StringAttribute{
				Computed:    true,
				Description: "Computed rendered manifest (multi-document YAML).",
				Sensitive:   true,
			},
			"status": schema.StringAttribute{
				Computed:    true,
				Description: "Computed release status (deployed, failed, pending-install, etc.).",
			},
			"revision": schema.Int64Attribute{
				Computed:    true,
				Description: "Computed release revision number.",
			},
			"metadata": schema.MapAttribute{
				Computed:    true,
				ElementType: types.StringType,
				Description: "Computed release metadata (chart version, app version, etc.).",
			},
		},
	}
}

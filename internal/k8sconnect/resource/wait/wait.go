package wait

import (
	"context"
	"fmt"
	"time"

	"github.com/hashicorp/terraform-plugin-framework-validators/mapvalidator"
	"github.com/hashicorp/terraform-plugin-framework-validators/stringvalidator"
	"github.com/hashicorp/terraform-plugin-framework/path"
	"github.com/hashicorp/terraform-plugin-framework/resource"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/planmodifier"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/stringplanmodifier"
	"github.com/hashicorp/terraform-plugin-framework/schema/validator"
	"github.com/hashicorp/terraform-plugin-framework/types"
	"github.com/hashicorp/terraform-plugin-framework/types/basetypes"

	"github.com/jmorris0x0/terraform-provider-k8sconnect/internal/k8sconnect/common/auth"
	"github.com/jmorris0x0/terraform-provider-k8sconnect/internal/k8sconnect/common/factory"
	"github.com/jmorris0x0/terraform-provider-k8sconnect/internal/k8sconnect/common/k8sclient"
	"github.com/jmorris0x0/terraform-provider-k8sconnect/internal/k8sconnect/common/validators"
)

var _ resource.Resource = (*waitResource)(nil)
var _ resource.ResourceWithConfigure = (*waitResource)(nil)
var _ resource.ResourceWithConfigValidators = (*waitResource)(nil)

// ClientGetter function type for dependency injection
type ClientGetter func(auth.ClusterModel) (k8sclient.K8sClient, error)

type waitResource struct {
	clientGetter  ClientGetter
	clientFactory factory.ClientFactory
}

type waitResourceModel struct {
	ID        types.String  `tfsdk:"id"`
	ObjectRef types.Object  `tfsdk:"object_ref"`
	Cluster   types.Object  `tfsdk:"cluster"`
	WaitFor   types.Object  `tfsdk:"wait_for"`
	Result    types.Dynamic `tfsdk:"result"`
}

// objectRefModel defines the structure for referencing a Kubernetes object
type objectRefModel struct {
	APIVersion types.String `tfsdk:"api_version"`
	Kind       types.String `tfsdk:"kind"`
	Name       types.String `tfsdk:"name"`
	Namespace  types.String `tfsdk:"namespace"`
}

// waitForModel defines wait conditions (transplanted from manifest resource)
type waitForModel struct {
	Field      types.String `tfsdk:"field"`
	FieldValue types.Map    `tfsdk:"field_value"`
	Condition  types.String `tfsdk:"condition"`
	Rollout    types.Bool   `tfsdk:"rollout"`
	Timeout    types.String `tfsdk:"timeout"`
}

// Creates a wait resource with custom client getter
func NewWaitResourceWithClientGetter(getter ClientGetter) resource.Resource {
	return &waitResource{
		clientGetter: getter,
	}
}

func (r *waitResource) Metadata(ctx context.Context, req resource.MetadataRequest, resp *resource.MetadataResponse) {
	resp.TypeName = req.ProviderTypeName + "_wait"
}

func (r *waitResource) Configure(ctx context.Context, req resource.ConfigureRequest, resp *resource.ConfigureResponse) {
	// Skip if provider data is not available (e.g., during planning)
	if req.ProviderData == nil {
		return
	}

	// Try to get client factory directly
	clientFactory, ok := req.ProviderData.(factory.ClientFactory)
	if !ok {
		resp.Diagnostics.AddError(
			"Unexpected Provider Data Type",
			"Expected factory.ClientFactory but got something else. This is a provider bug.",
		)
		return
	}

	// Store the client factory
	r.clientFactory = clientFactory

	// For backward compatibility, create a clientGetter that uses the factory
	r.clientGetter = func(conn auth.ClusterModel) (k8sclient.K8sClient, error) {
		return r.clientFactory.GetClient(conn)
	}
}

func (r *waitResource) Schema(ctx context.Context, req resource.SchemaRequest, resp *resource.SchemaResponse) {
	resp.Schema = schema.Schema{
		Version: 1,
		Description: "Waits for a Kubernetes resource to reach a desired state. " +
			"Use this resource to wait for resources created by k8sconnect_object without risking resource tainting on timeout. " +
			"Follows the pattern: create resource -> wait for readiness -> use outputs.",
		Attributes: map[string]schema.Attribute{
			"id": schema.StringAttribute{
				Computed: true,
				PlanModifiers: []planmodifier.String{
					stringplanmodifier.UseStateForUnknown(),
				},
				Description: "Unique identifier for this wait operation (generated by the provider).",
			},
			"object_ref": schema.SingleNestedAttribute{
				Required: true,
				Description: "Reference to the Kubernetes object to wait for. " +
					"Typically populated from k8sconnect_object.resource_name.object_ref output.",
				Attributes: map[string]schema.Attribute{
					"api_version": schema.StringAttribute{
						Required:    true,
						Description: "Kubernetes API version (e.g., 'v1', 'apps/v1')",
					},
					"kind": schema.StringAttribute{
						Required:    true,
						Description: "Kubernetes resource kind (e.g., 'Pod', 'Deployment')",
					},
					"name": schema.StringAttribute{
						Required:    true,
						Description: "Resource name",
					},
					"namespace": schema.StringAttribute{
						Optional:    true,
						Description: "Resource namespace. Omit for cluster-scoped resources.",
					},
				},
			},
			"cluster": schema.SingleNestedAttribute{
				Required: true,
				Description: "Kubernetes cluster connection for accessing the resource. " +
					"Should match the connection used by the k8sconnect_object resource.",
				Attributes: auth.GetConnectionSchemaForResource(),
			},
			"wait_for": schema.SingleNestedAttribute{
				Required:    true,
				Description: "Conditions to wait for before considering the resource ready.",
				Attributes: map[string]schema.Attribute{
					"field": schema.StringAttribute{
						Optional:    true,
						Description: "JSONPath to field that must exist/be non-empty. Example: 'status.loadBalancer.ingress'",
						Validators: []validator.String{
							stringvalidator.ConflictsWith(
								path.MatchRelative().AtParent().AtName("field_value"),
								path.MatchRelative().AtParent().AtName("condition"),
							),
							validators.JSONPath{},
						},
					},
					"field_value": schema.MapAttribute{
						Optional:    true,
						ElementType: types.StringType,
						Description: "Map of JSONPath to expected value. Example: {'status.phase': 'Running'}",
						Validators: []validator.Map{
							mapvalidator.ConflictsWith(
								path.MatchRelative().AtParent().AtName("field"),
								path.MatchRelative().AtParent().AtName("condition"),
							),
							validators.JSONPathMapKeys{},
						},
					},
					"condition": schema.StringAttribute{
						Optional:    true,
						Description: "Condition type that must be True. Example: 'Ready'",
						Validators: []validator.String{
							stringvalidator.ConflictsWith(
								path.MatchRelative().AtParent().AtName("field"),
								path.MatchRelative().AtParent().AtName("field_value"),
							),
						},
					},
					"rollout": schema.BoolAttribute{
						Optional: true,
						Description: "Wait for Deployment/StatefulSet/DaemonSet to complete rollout. " +
							"Checks that all replicas are updated and available.",
					},
					"timeout": schema.StringAttribute{
						Optional:    true,
						Description: "Maximum time to wait. Defaults to 10m. Format: '30s', '5m', '1h'",
						Validators: []validator.String{
							durationValidator{},
						},
					},
				},
			},
			"result": schema.DynamicAttribute{
				Computed: true,
				Description: "Result of the wait operation containing extracted fields from the Kubernetes resource. " +
					"The structure preserves the full path from the resource (e.g., field='spec.volumeName' â†’ result.spec.volumeName). " +
					"Follows ADR-008: 'You get only what you wait for' - only populated for field waits, null for condition/rollout waits.",
			},
		},
	}
}

// CRUD operations are implemented in crud.go

func (r *waitResource) Delete(ctx context.Context, req resource.DeleteRequest, resp *resource.DeleteResponse) {
	// Wait resources are ephemeral - deletion just removes from state
	// No actual cluster cleanup needed since we don't create anything
}

func (r *waitResource) ConfigValidators(ctx context.Context) []resource.ConfigValidator {
	return []resource.ConfigValidator{
		&rolloutKindValidator{},
	}
}

// rolloutKindValidator validates that rollout waits are only used on appropriate resource kinds
type rolloutKindValidator struct{}

func (v rolloutKindValidator) Description(ctx context.Context) string {
	return "validates that rollout waits are not used on resource kinds that don't support rollouts"
}

func (v rolloutKindValidator) MarkdownDescription(ctx context.Context) string {
	return "validates that rollout waits are not used on resource kinds that don't support rollouts"
}

func (v rolloutKindValidator) ValidateResource(ctx context.Context, req resource.ValidateConfigRequest, resp *resource.ValidateConfigResponse) {
	var data waitResourceModel
	diags := req.Config.Get(ctx, &data)
	resp.Diagnostics.Append(diags...)
	if resp.Diagnostics.HasError() {
		return
	}

	// Skip validation if wait_for or object_ref contain unknown values
	if data.WaitFor.IsUnknown() || data.ObjectRef.IsUnknown() {
		return
	}

	// Extract wait_for and object_ref
	var waitFor waitForModel
	diags = data.WaitFor.As(ctx, &waitFor, basetypes.ObjectAsOptions{})
	resp.Diagnostics.Append(diags...)
	if resp.Diagnostics.HasError() {
		return
	}

	var objRef objectRefModel
	diags = data.ObjectRef.As(ctx, &objRef, basetypes.ObjectAsOptions{})
	resp.Diagnostics.Append(diags...)
	if resp.Diagnostics.HasError() {
		return
	}

	// Only validate if rollout is true
	if waitFor.Rollout.IsNull() || !waitFor.Rollout.ValueBool() {
		return
	}

	kind := objRef.Kind.ValueString()

	// Blocklist of known resource kinds that definitely don't support rollouts
	nonRolloutKinds := map[string]bool{
		"ConfigMap":               true,
		"Secret":                  true,
		"Service":                 true,
		"Namespace":               true,
		"ServiceAccount":          true,
		"PersistentVolumeClaim":   true,
		"PersistentVolume":        true,
		"Ingress":                 true,
		"NetworkPolicy":           true,
		"ResourceQuota":           true,
		"LimitRange":              true,
		"PodDisruptionBudget":     true,
		"HorizontalPodAutoscaler": true,
		"ClusterRole":             true,
		"ClusterRoleBinding":      true,
		"Role":                    true,
		"RoleBinding":             true,
		"StorageClass":            true,
		"Node":                    true,
		"Pod":                     true, // Pods don't rollout - they just exist or don't
	}

	if nonRolloutKinds[kind] {
		resp.Diagnostics.AddError(
			"Rollout Not Supported",
			fmt.Sprintf("%s resources do not support rollout waits. "+
				"Rollout waits are only supported for resources that track rollout status (like Deployment, StatefulSet, DaemonSet). "+
				"Use wait_for.condition or wait_for.field instead.", kind),
		)
	}
}

// durationValidator validates that a string is a valid duration
type durationValidator struct{}

func (v durationValidator) Description(ctx context.Context) string {
	return "validates that the value is a valid duration"
}

func (v durationValidator) MarkdownDescription(ctx context.Context) string {
	return "validates that the value is a valid Go duration (e.g., '30s', '5m', '1h')"
}

func (v durationValidator) ValidateString(ctx context.Context, req validator.StringRequest, resp *validator.StringResponse) {
	if req.ConfigValue.IsNull() || req.ConfigValue.IsUnknown() {
		return // Skip validation for unknown/null values
	}

	value := req.ConfigValue.ValueString()
	duration, err := time.ParseDuration(value)
	if err != nil {
		resp.Diagnostics.AddAttributeError(
			req.Path,
			"Invalid Duration",
			fmt.Sprintf("The value '%s' is not a valid duration: %s. Use format like '30s', '5m', '1h'", value, err),
		)
		return
	}

	// Reject zero or negative durations
	if duration <= 0 {
		resp.Diagnostics.AddAttributeError(
			req.Path,
			"Invalid Timeout",
			fmt.Sprintf("Timeout must be positive, got '%s'. Use a positive duration like '30s', '5m', or '1h'", value),
		)
	}
}

// formatObjectRef creates a human-readable description of a Kubernetes resource
// from an objectRefModel, handling both namespaced and cluster-scoped resources.
// Examples:
//   - Namespaced: "Deployment nginx (namespace: default)"
//   - Cluster-scoped: "Namespace production" or "ClusterRole admin"
func formatObjectRef(objRef objectRefModel) string {
	kind := objRef.Kind.ValueString()
	name := objRef.Name.ValueString()
	namespace := objRef.Namespace.ValueString()

	if namespace == "" {
		// Cluster-scoped resource
		return fmt.Sprintf("%s %s", kind, name)
	}
	// Namespaced resource
	return fmt.Sprintf("%s %s (namespace: %s)", kind, name, namespace)
}

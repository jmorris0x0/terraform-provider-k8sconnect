package wait

import (
	"context"
	"fmt"
	"time"

	"github.com/hashicorp/terraform-plugin-framework-validators/mapvalidator"
	"github.com/hashicorp/terraform-plugin-framework-validators/stringvalidator"
	"github.com/hashicorp/terraform-plugin-framework/path"
	"github.com/hashicorp/terraform-plugin-framework/resource"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/planmodifier"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/stringplanmodifier"
	"github.com/hashicorp/terraform-plugin-framework/schema/validator"
	"github.com/hashicorp/terraform-plugin-framework/types"

	"github.com/jmorris0x0/terraform-provider-k8sconnect/internal/k8sconnect/common/auth"
	"github.com/jmorris0x0/terraform-provider-k8sconnect/internal/k8sconnect/common/factory"
	"github.com/jmorris0x0/terraform-provider-k8sconnect/internal/k8sconnect/common/k8sclient"
	"github.com/jmorris0x0/terraform-provider-k8sconnect/internal/k8sconnect/common/validators"
)

var _ resource.Resource = (*waitResource)(nil)
var _ resource.ResourceWithConfigure = (*waitResource)(nil)

// ClientGetter function type for dependency injection
type ClientGetter func(auth.ClusterConnectionModel) (k8sclient.K8sClient, error)

type waitResource struct {
	clientGetter  ClientGetter
	clientFactory factory.ClientFactory
}

type waitResourceModel struct {
	ID                types.String  `tfsdk:"id"`
	ObjectRef         types.Object  `tfsdk:"object_ref"`
	ClusterConnection types.Object  `tfsdk:"cluster_connection"`
	WaitFor           types.Object  `tfsdk:"wait_for"`
	Result            types.Dynamic `tfsdk:"result"`
}

// objectRefModel defines the structure for referencing a Kubernetes object
type objectRefModel struct {
	APIVersion types.String `tfsdk:"api_version"`
	Kind       types.String `tfsdk:"kind"`
	Name       types.String `tfsdk:"name"`
	Namespace  types.String `tfsdk:"namespace"`
}

// waitForModel defines wait conditions (transplanted from manifest resource)
type waitForModel struct {
	Field      types.String `tfsdk:"field"`
	FieldValue types.Map    `tfsdk:"field_value"`
	Condition  types.String `tfsdk:"condition"`
	Rollout    types.Bool   `tfsdk:"rollout"`
	Timeout    types.String `tfsdk:"timeout"`
}

// Creates a wait resource with custom client getter
func NewWaitResourceWithClientGetter(getter ClientGetter) resource.Resource {
	return &waitResource{
		clientGetter: getter,
	}
}

func (r *waitResource) Metadata(ctx context.Context, req resource.MetadataRequest, resp *resource.MetadataResponse) {
	resp.TypeName = req.ProviderTypeName + "_wait"
}

func (r *waitResource) Configure(ctx context.Context, req resource.ConfigureRequest, resp *resource.ConfigureResponse) {
	// Skip if provider data is not available (e.g., during planning)
	if req.ProviderData == nil {
		return
	}

	// Try to get client factory directly
	clientFactory, ok := req.ProviderData.(factory.ClientFactory)
	if !ok {
		resp.Diagnostics.AddError(
			"Unexpected Provider Data Type",
			"Expected factory.ClientFactory but got something else. This is a provider bug.",
		)
		return
	}

	// Store the client factory
	r.clientFactory = clientFactory

	// For backward compatibility, create a clientGetter that uses the factory
	r.clientGetter = func(conn auth.ClusterConnectionModel) (k8sclient.K8sClient, error) {
		return r.clientFactory.GetClient(conn)
	}
}

func (r *waitResource) Schema(ctx context.Context, req resource.SchemaRequest, resp *resource.SchemaResponse) {
	resp.Schema = schema.Schema{
		Description: "Waits for a Kubernetes resource to reach a desired state. " +
			"Use this resource to wait for resources created by k8sconnect_object without risking resource tainting on timeout. " +
			"Follows the pattern: create resource -> wait for readiness -> use outputs.",
		Attributes: map[string]schema.Attribute{
			"id": schema.StringAttribute{
				Computed: true,
				PlanModifiers: []planmodifier.String{
					stringplanmodifier.UseStateForUnknown(),
				},
				Description: "Unique identifier for this wait operation (generated by the provider).",
			},
			"object_ref": schema.SingleNestedAttribute{
				Required: true,
				Description: "Reference to the Kubernetes object to wait for. " +
					"Typically populated from k8sconnect_object.resource_name.object_ref output.",
				Attributes: map[string]schema.Attribute{
					"api_version": schema.StringAttribute{
						Required:    true,
						Description: "Kubernetes API version (e.g., 'v1', 'apps/v1')",
					},
					"kind": schema.StringAttribute{
						Required:    true,
						Description: "Kubernetes resource kind (e.g., 'Pod', 'Deployment')",
					},
					"name": schema.StringAttribute{
						Required:    true,
						Description: "Resource name",
					},
					"namespace": schema.StringAttribute{
						Optional:    true,
						Description: "Resource namespace. Omit for cluster-scoped resources.",
					},
				},
			},
			"cluster_connection": schema.SingleNestedAttribute{
				Required: true,
				Description: "Kubernetes cluster connection for accessing the resource. " +
					"Should match the connection used by the k8sconnect_object resource.",
				Attributes: auth.GetConnectionSchemaForResource(),
			},
			"wait_for": schema.SingleNestedAttribute{
				Required:    true,
				Description: "Conditions to wait for before considering the resource ready.",
				Attributes: map[string]schema.Attribute{
					"field": schema.StringAttribute{
						Optional:    true,
						Description: "JSONPath to field that must exist/be non-empty. Example: 'status.loadBalancer.ingress'",
						Validators: []validator.String{
							stringvalidator.ConflictsWith(
								path.MatchRelative().AtParent().AtName("field_value"),
								path.MatchRelative().AtParent().AtName("condition"),
							),
							validators.JSONPath{},
						},
					},
					"field_value": schema.MapAttribute{
						Optional:    true,
						ElementType: types.StringType,
						Description: "Map of JSONPath to expected value. Example: {'status.phase': 'Running'}",
						Validators: []validator.Map{
							mapvalidator.ConflictsWith(
								path.MatchRelative().AtParent().AtName("field"),
								path.MatchRelative().AtParent().AtName("condition"),
							),
							validators.JSONPathMapKeys{},
						},
					},
					"condition": schema.StringAttribute{
						Optional:    true,
						Description: "Condition type that must be True. Example: 'Ready'",
						Validators: []validator.String{
							stringvalidator.ConflictsWith(
								path.MatchRelative().AtParent().AtName("field"),
								path.MatchRelative().AtParent().AtName("field_value"),
							),
						},
					},
					"rollout": schema.BoolAttribute{
						Optional: true,
						Description: "Wait for Deployment/StatefulSet/DaemonSet to complete rollout. " +
							"Checks that all replicas are updated and available.",
					},
					"timeout": schema.StringAttribute{
						Optional:    true,
						Description: "Maximum time to wait. Defaults to 10m. Format: '30s', '5m', '1h'",
						Validators: []validator.String{
							durationValidator{},
						},
					},
				},
			},
			"result": schema.DynamicAttribute{
				Computed: true,
				Description: "Result of the wait operation containing extracted fields from the Kubernetes resource. " +
					"The structure preserves the full path from the resource (e.g., field='spec.volumeName' â†’ result.spec.volumeName). " +
					"Follows ADR-008: 'You get only what you wait for' - only populated for field waits, null for condition/rollout waits.",
			},
		},
	}
}

// CRUD operations are implemented in crud.go

func (r *waitResource) Delete(ctx context.Context, req resource.DeleteRequest, resp *resource.DeleteResponse) {
	// Wait resources are ephemeral - deletion just removes from state
	// No actual cluster cleanup needed since we don't create anything
}

// durationValidator validates that a string is a valid duration
type durationValidator struct{}

func (v durationValidator) Description(ctx context.Context) string {
	return "validates that the value is a valid duration"
}

func (v durationValidator) MarkdownDescription(ctx context.Context) string {
	return "validates that the value is a valid Go duration (e.g., '30s', '5m', '1h')"
}

func (v durationValidator) ValidateString(ctx context.Context, req validator.StringRequest, resp *validator.StringResponse) {
	if req.ConfigValue.IsNull() || req.ConfigValue.IsUnknown() {
		return // Skip validation for unknown/null values
	}

	value := req.ConfigValue.ValueString()
	_, err := time.ParseDuration(value)
	if err != nil {
		resp.Diagnostics.AddAttributeError(
			req.Path,
			"Invalid Duration",
			fmt.Sprintf("The value '%s' is not a valid duration: %s. Use format like '30s', '5m', '1h'", value, err),
		)
	}
}

// formatObjectRef creates a human-readable description of a Kubernetes resource
// from an objectRefModel, handling both namespaced and cluster-scoped resources.
// Examples:
//   - Namespaced: "Deployment nginx (namespace: default)"
//   - Cluster-scoped: "Namespace production" or "ClusterRole admin"
func formatObjectRef(objRef objectRefModel) string {
	kind := objRef.Kind.ValueString()
	name := objRef.Name.ValueString()
	namespace := objRef.Namespace.ValueString()

	if namespace == "" {
		// Cluster-scoped resource
		return fmt.Sprintf("%s %s", kind, name)
	}
	// Namespaced resource
	return fmt.Sprintf("%s %s (namespace: %s)", kind, name, namespace)
}

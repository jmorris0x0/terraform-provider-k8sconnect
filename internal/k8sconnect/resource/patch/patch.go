package patch

import (
	"context"

	"github.com/hashicorp/terraform-plugin-framework/resource"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema"

	"github.com/hashicorp/terraform-plugin-framework-validators/stringvalidator"
	"github.com/hashicorp/terraform-plugin-framework/path"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/planmodifier"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/stringplanmodifier"
	"github.com/hashicorp/terraform-plugin-framework/schema/validator"
	"github.com/hashicorp/terraform-plugin-framework/types"

	"github.com/jmorris0x0/terraform-provider-k8sconnect/internal/k8sconnect/common/auth"
	"github.com/jmorris0x0/terraform-provider-k8sconnect/internal/k8sconnect/common/factory"
	"github.com/jmorris0x0/terraform-provider-k8sconnect/internal/k8sconnect/common/k8sclient"
	"github.com/jmorris0x0/terraform-provider-k8sconnect/internal/k8sconnect/common/validators"
)

var _ resource.Resource = (*patchResource)(nil)
var _ resource.ResourceWithConfigValidators = (*patchResource)(nil)
var _ resource.ResourceWithImportState = (*patchResource)(nil)
var _ resource.ResourceWithConfigure = (*patchResource)(nil)
var _ resource.ResourceWithModifyPlan = (*patchResource)(nil)
var _ resource.ResourceWithUpgradeState = (*patchResource)(nil)

// ClientGetter function type for dependency injection
type ClientGetter func(auth.ClusterModel) (k8sclient.K8sClient, error)

type patchResource struct {
	clientGetter  ClientGetter
	clientFactory factory.ClientFactory
}

type patchResourceModel struct {
	ID         types.String `tfsdk:"id"`
	Target     types.Object `tfsdk:"target"`
	Patch      types.String `tfsdk:"patch"`
	JSONPatch  types.String `tfsdk:"json_patch"`
	MergePatch types.String `tfsdk:"merge_patch"`
	Cluster    types.Object `tfsdk:"cluster"`

	// Computed fields

	ManagedStateProjection types.Map    `tfsdk:"managed_state_projection"`
	FieldOwnership         types.Map    `tfsdk:"field_ownership"`
	ManagedFields          types.String `tfsdk:"managed_fields"`
}

type patchTargetModel struct {
	APIVersion types.String `tfsdk:"api_version"`
	Kind       types.String `tfsdk:"kind"`
	Name       types.String `tfsdk:"name"`
	Namespace  types.String `tfsdk:"namespace"`
}

// NewPatchResourceWithClientGetter creates a patch resource with custom client getter
func NewPatchResourceWithClientGetter(getter ClientGetter) resource.Resource {
	return &patchResource{
		clientGetter: getter,
	}
}

func (r *patchResource) Metadata(ctx context.Context, req resource.MetadataRequest, resp *resource.MetadataResponse) {
	resp.TypeName = req.ProviderTypeName + "_patch"
}

func (r *patchResource) Configure(ctx context.Context, req resource.ConfigureRequest, resp *resource.ConfigureResponse) {
	// Skip if provider data is not available (e.g., during planning)
	if req.ProviderData == nil {
		return
	}

	// Try to get client factory
	clientFactory, ok := req.ProviderData.(factory.ClientFactory)
	if !ok {
		resp.Diagnostics.AddError(
			"Unexpected Provider Data Type",
			"Expected factory.ClientFactory but got something else. This is a provider bug.",
		)
		return
	}

	// Store the client factory
	r.clientFactory = clientFactory

	// For backward compatibility, create a clientGetter that uses the factory
	r.clientGetter = func(conn auth.ClusterModel) (k8sclient.K8sClient, error) {
		return r.clientFactory.GetClient(conn)
	}
}

func (r *patchResource) Schema(ctx context.Context, req resource.SchemaRequest, resp *resource.SchemaResponse) {
	resp.Schema = schema.Schema{
		Version: 1,
		MarkdownDescription: `Applies targeted patches to existing Kubernetes resources using Server-Side Apply.

**IMPORTANT:** This resource forcefully takes ownership of fields from other controllers.

**Appropriate use cases:**
- Cloud provider system resources (AWS EKS, GCP GKE, Azure AKS defaults)
- Operator-managed resources (cert-manager, nginx-ingress, etc.)
- Helm chart deployments requiring customization
- Resources created and managed by other tools

**NOT appropriate for:**
- Resources managed by k8sconnect_object in the same state
- Resources requiring full lifecycle control
- Resources you could manage with k8sconnect_object instead

**Destroy behavior:**
When you destroy a patch resource, ownership is released but patched values remain on the target resource. Values are not reverted to their original state.`,

		Attributes: map[string]schema.Attribute{
			"id": schema.StringAttribute{
				Computed: true,
				PlanModifiers: []planmodifier.String{
					stringplanmodifier.UseStateForUnknown(),
				},
				Description: "Unique identifier for this patch (generated by the provider).",
			},

			"target": schema.SingleNestedAttribute{
				Required:    true,
				Description: "Identifies the Kubernetes resource to patch. The resource must already exist. Changes to target require replacement.",
				Attributes: map[string]schema.Attribute{
					"api_version": schema.StringAttribute{
						Required:    true,
						Description: "API version of the target resource (e.g., 'apps/v1', 'v1'). Changes require replacement.",
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplace(),
						},
					},
					"kind": schema.StringAttribute{
						Required:    true,
						Description: "Kind of the target resource (e.g., 'DaemonSet', 'Deployment'). Changes require replacement.",
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplace(),
						},
					},
					"name": schema.StringAttribute{
						Required:    true,
						Description: "Name of the target resource. Changes require replacement.",
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplace(),
						},
					},
					"namespace": schema.StringAttribute{
						Optional:    true,
						Description: "Namespace of the target resource. Omit for cluster-scoped resources. Changes require replacement.",
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplace(),
						},
					},
				},
			},

			"patch": schema.StringAttribute{
				Optional: true,
				MarkdownDescription: "Strategic merge patch content (YAML or JSON). This is the recommended patch type for most use cases. " +
					"Uses Kubernetes strategic merge semantics with merge keys for arrays.",
				Validators: []validator.String{
					stringvalidator.ConflictsWith(
						path.MatchRoot("json_patch"),
						path.MatchRoot("merge_patch"),
					),
					stringvalidator.AtLeastOneOf(
						path.MatchRoot("patch"),
						path.MatchRoot("json_patch"),
						path.MatchRoot("merge_patch"),
					),
					validators.StrategicMergePatch{},
				},
			},

			"json_patch": schema.StringAttribute{
				Optional: true,
				MarkdownDescription: "JSON Patch (RFC 6902) operations as JSON array. " +
					"Use for precise operations like adding/removing specific array elements. " +
					"Example: `[{\"op\":\"add\",\"path\":\"/metadata/labels/foo\",\"value\":\"bar\"}]`.",
				Validators: []validator.String{
					stringvalidator.ConflictsWith(
						path.MatchRoot("patch"),
						path.MatchRoot("merge_patch"),
					),
					stringvalidator.AtLeastOneOf(
						path.MatchRoot("patch"),
						path.MatchRoot("json_patch"),
						path.MatchRoot("merge_patch"),
					),
					validators.JSONPatchValidator{},
				},
			},

			"merge_patch": schema.StringAttribute{
				Optional: true,
				MarkdownDescription: "JSON Merge Patch (RFC 7386) content. " +
					"Simple key-value merges, replaces entire arrays. " +
					"Least powerful but simplest patch type.",
				Validators: []validator.String{
					stringvalidator.ConflictsWith(
						path.MatchRoot("patch"),
						path.MatchRoot("json_patch"),
					),
					stringvalidator.AtLeastOneOf(
						path.MatchRoot("patch"),
						path.MatchRoot("json_patch"),
						path.MatchRoot("merge_patch"),
					),
					validators.MergePatchValidator{},
				},
			},

			"cluster": schema.SingleNestedAttribute{
				Required: true,
				Description: "Kubernetes cluster connection for this specific patch. Can be different per-resource, enabling multi-cluster " +
					"deployments without provider aliases. Supports inline credentials (token, exec, client certs) or kubeconfig.",
				Attributes: auth.GetConnectionSchemaForResource(),
			},

			// Computed fields
			"managed_state_projection": schema.MapAttribute{
				Computed:    true,
				ElementType: types.StringType,
				Description: "Flattened projection of fields that will be patched. Shows the predicted state after patch " +
					"application, including any Kubernetes defaults. Only available for strategic merge patches (SSA). " +
					"Non-SSA patches (json_patch, merge_patch) do not provide projection.",
			},

			"field_ownership": schema.MapAttribute{
				Computed:    true,
				ElementType: types.StringType,
				Description: "Tracks which field manager owns each field path in the patched resource. " +
					"Shows 'k8sconnect' for fields managed by this provider, or external manager names (e.g., 'kubectl', 'hpa-controller') for fields managed by other systems. " +
					"When ownership changes appear in diffs, it indicates another system has taken control of those fields.",
			},

			"managed_fields": schema.StringAttribute{
				Computed:    true,
				Description: "JSON representation of only the fields managed by this patch. Used for drift detection.",
			},
		},
	}
}

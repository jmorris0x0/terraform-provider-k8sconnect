// internal/k8sconnect/resource/manifest/manifest.go
package manifest

import (
	"context"

	"github.com/hashicorp/terraform-plugin-framework/resource"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema"
	//"github.com/hashicorp/terraform-plugin-framework/resource/schema/dynamicplanmodifier"
	"github.com/hashicorp/terraform-plugin-framework-validators/mapvalidator"
	"github.com/hashicorp/terraform-plugin-framework-validators/stringvalidator"
	"github.com/hashicorp/terraform-plugin-framework/path"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/planmodifier"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/stringplanmodifier"
	"github.com/hashicorp/terraform-plugin-framework/schema/validator"
	"github.com/hashicorp/terraform-plugin-framework/types"

	"github.com/jmorris0x0/terraform-provider-k8sconnect/internal/k8sconnect/common"
	"github.com/jmorris0x0/terraform-provider-k8sconnect/internal/k8sconnect/common/auth"
	"github.com/jmorris0x0/terraform-provider-k8sconnect/internal/k8sconnect/common/client"
	"github.com/jmorris0x0/terraform-provider-k8sconnect/internal/k8sconnect/k8sclient"
)

var _ resource.Resource = (*manifestResource)(nil)
var _ resource.ResourceWithConfigValidators = (*manifestResource)(nil)
var _ resource.ResourceWithModifyPlan = (*manifestResource)(nil)
var _ resource.ResourceWithImportState = (*manifestResource)(nil)
var _ resource.ResourceWithConfigure = (*manifestResource)(nil)

// ClientGetter function type for dependency injection
type ClientGetter func(auth.ClusterConnectionModel) (k8sclient.K8sClient, error)

type manifestResource struct {
	clientGetter ClientGetter // Keep for backward compatibility

	// New fields for connection config
	connResolver  *auth.ConnectionResolver
	clientFactory client.ClientFactory
}

type manifestResourceModel struct {
	ID                         types.String  `tfsdk:"id"`
	YAMLBody                   types.String  `tfsdk:"yaml_body"`
	ClusterConnection          types.Object  `tfsdk:"cluster_connection"`
	DeleteProtection           types.Bool    `tfsdk:"delete_protection"`
	DeleteTimeout              types.String  `tfsdk:"delete_timeout"`
	FieldOwnership             types.String  `tfsdk:"field_ownership"`
	ForceDestroy               types.Bool    `tfsdk:"force_destroy"`
	ForceConflicts             types.Bool    `tfsdk:"force_conflicts"`
	ManagedStateProjection     types.String  `tfsdk:"managed_state_projection"`
	ImportedWithoutAnnotations types.Bool    `tfsdk:"imported_without_annotations"`
	WaitFor                    types.Object  `tfsdk:"wait_for"`
	Status                     types.Dynamic `tfsdk:"status"`
}

type waitForModel struct {
	Field      types.String `tfsdk:"field"`
	FieldValue types.Map    `tfsdk:"field_value"`
	Condition  types.String `tfsdk:"condition"`
	Rollout    types.Bool   `tfsdk:"rollout"`
	Timeout    types.String `tfsdk:"timeout"`
}

// Creates a manifest resource with custom client getter
func NewManifestResourceWithClientGetter(getter ClientGetter) resource.Resource {
	return &manifestResource{
		clientGetter: getter,
	}
}

func (r *manifestResource) Metadata(ctx context.Context, req resource.MetadataRequest, resp *resource.MetadataResponse) {
	resp.TypeName = req.ProviderTypeName + "_manifest"
}

func (r *manifestResource) Configure(ctx context.Context, req resource.ConfigureRequest, resp *resource.ConfigureResponse) {
	// Skip if provider data is not available (e.g., during planning)
	if req.ProviderData == nil {
		return
	}

	// Try to get connection config
	connectionConfig, ok := req.ProviderData.(*common.ConnectionConfig)
	if !ok {
		resp.Diagnostics.AddError(
			"Unexpected Provider Data Type",
			"Expected *common.ConnectionConfig but got something else. This is a provider bug.",
		)
		return
	}

	// Store the components
	r.connResolver = connectionConfig.ConnectionResolver
	r.clientFactory = connectionConfig.ClientFactory

	// For backward compatibility, create a clientGetter that uses the factory
	r.clientGetter = func(conn auth.ClusterConnectionModel) (k8sclient.K8sClient, error) {
		return r.clientFactory.GetClient(conn)
	}
}

func (r *manifestResource) Schema(ctx context.Context, req resource.SchemaRequest, resp *resource.SchemaResponse) {
	resp.Schema = schema.Schema{
		Description: "Applies a single‑document Kubernetes YAML manifest to a cluster, with per‑resource inline or kubeconfig‑based connection settings.",
		Attributes: map[string]schema.Attribute{
			"id": schema.StringAttribute{
				Computed: true,
				PlanModifiers: []planmodifier.String{
					stringplanmodifier.UseStateForUnknown(),
				},
				Description: "Unique identifier for this manifest (generated by the provider).",
			},
			"yaml_body": schema.StringAttribute{
				Required:    true,
				Description: "UTF‑8 encoded, single‑document Kubernetes YAML. Multi‑doc files will fail validation.",
			},
			"cluster_connection": schema.SingleNestedAttribute{
				Optional:    true, // Changed from Required to Optional
				Description: "Cluster connection configuration for this resource. If not specified, uses the provider-level connection.",
				Attributes: map[string]schema.Attribute{
					"host": schema.StringAttribute{
						Optional:    true,
						Description: "The hostname (in form of URI) of the Kubernetes API server.",
					},
					"cluster_ca_certificate": schema.StringAttribute{
						Optional:    true,
						Description: "PEM-encoded root certificate bundle for TLS authentication.",
					},
					"kubeconfig_file": schema.StringAttribute{
						Optional:    true,
						Description: "Path to the kubeconfig file.",
					},
					"kubeconfig_raw": schema.StringAttribute{
						Optional:    true,
						Sensitive:   true,
						Description: "Raw kubeconfig file content.",
					},
					"context": schema.StringAttribute{
						Optional:    true,
						Description: "Context to use from the kubeconfig.",
					},
					"token": schema.StringAttribute{
						Optional:    true,
						Sensitive:   true,
						Description: "Token to authenticate to the Kubernetes API server.",
					},
					"client_certificate": schema.StringAttribute{
						Optional:    true,
						Description: "PEM-encoded client certificate for TLS authentication.",
					},
					"client_key": schema.StringAttribute{
						Optional:    true,
						Sensitive:   true,
						Description: "PEM-encoded client certificate key for TLS authentication.",
					},
					"insecure": schema.BoolAttribute{
						Optional:    true,
						Description: "Whether server should be accessed without verifying the TLS certificate.",
					},
					"proxy_url": schema.StringAttribute{
						Optional:    true,
						Description: "URL of the proxy to use for requests.",
					},
					"exec": schema.SingleNestedAttribute{
						Optional:    true,
						Description: "Configuration for exec-based authentication.",
						Attributes: map[string]schema.Attribute{
							"api_version": schema.StringAttribute{
								Required:    true,
								Description: "API version to use when encoding the ExecCredentials resource.",
							},
							"command": schema.StringAttribute{
								Required:    true,
								Description: "Command to execute.",
							},
							"args": schema.ListAttribute{
								Optional:    true,
								ElementType: types.StringType,
								Description: "Arguments to pass when executing the plugin.",
							},
							"env": schema.MapAttribute{
								Optional:    true,
								ElementType: types.StringType,
								Description: "Environment variables to set when executing the plugin.",
							},
						},
					},
				},
			},
			"delete_protection": schema.BoolAttribute{
				Optional:    true,
				Description: "Prevent accidental deletion of the resource. If set to true, the resource cannot be deleted unless this field is set to false.",
			},
			"delete_timeout": schema.StringAttribute{
				Optional:    true,
				Description: "How long to wait for a resource to be deleted before considering the deletion failed. Defaults to 300s (5 minutes).",
			},
			"force_destroy": schema.BoolAttribute{
				Optional:    true,
				Description: "Force destroy resources that have finalizers and are stuck in 'Terminating' state. This removes finalizers before deletion.",
			},
			"managed_state_projection": schema.StringAttribute{
				Computed:    true,
				Description: "Internal field used to track managed fields for accurate drift detection.",
			},
			"imported_without_annotations": schema.BoolAttribute{
				Computed:    true,
				Description: "Internal flag tracking if resource was imported without ownership annotations",
			},
			"force_conflicts": schema.BoolAttribute{
				Optional:    true,
				Description: "Force field manager conflicts during server-side apply. When false (default), operations will fail if another field manager owns the field. When true, forcibly takes ownership of conflicting fields.",
			},
			"field_ownership": schema.StringAttribute{
				Computed:    true,
				Description: "Internal tracking of field ownership by different controllers",
			},
			"status": schema.DynamicAttribute{
				Computed:    true,
				Description: "Status subresource from the live cluster state. Contains conditions, phase, and resource-specific fields like loadBalancer for Services.",
			},
			"wait_for": schema.SingleNestedAttribute{
				Optional:    true,
				Description: "Wait for resource to reach desired state during apply. Automatically enables status tracking.",
				Attributes: map[string]schema.Attribute{
					"field": schema.StringAttribute{
						Optional:    true,
						Description: "JSONPath to field that must exist/be non-empty. Example: 'status.loadBalancer.ingress'",
						Validators: []validator.String{
							stringvalidator.ConflictsWith(
								path.MatchRelative().AtParent().AtName("field_value"),
								path.MatchRelative().AtParent().AtName("condition"),
							),
						},
					},
					"field_value": schema.MapAttribute{
						Optional:    true,
						ElementType: types.StringType,
						Description: "Map of JSONPath to expected value. Example: {'status.phase': 'Running'}",
						Validators: []validator.Map{
							mapvalidator.ConflictsWith(
								path.MatchRelative().AtParent().AtName("field"),
								path.MatchRelative().AtParent().AtName("condition"),
							),
						},
					},
					"condition": schema.StringAttribute{
						Optional:    true,
						Description: "Condition type that must be True. Example: 'Ready'",
						Validators: []validator.String{
							stringvalidator.ConflictsWith(
								path.MatchRelative().AtParent().AtName("field"),
								path.MatchRelative().AtParent().AtName("field_value"),
							),
						},
					},
					"rollout": schema.BoolAttribute{
						Optional:    true,
						Description: "Wait for Deployment/StatefulSet/DaemonSet rollout. Auto-enabled for these types unless set to false.",
					},
					"timeout": schema.StringAttribute{
						Optional:    true,
						Description: "Maximum time to wait. Defaults to 10m. Format: '30s', '5m', '1h'",
					},
				},
			},
		},
	}
}

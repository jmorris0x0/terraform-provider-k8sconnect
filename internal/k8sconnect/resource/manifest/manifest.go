// internal/k8sconnect/resource/manifest/manifest.go
package manifest

import (
	"context"

	"github.com/hashicorp/terraform-plugin-framework/resource"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema"

	"github.com/hashicorp/terraform-plugin-framework-validators/listvalidator"
	"github.com/hashicorp/terraform-plugin-framework-validators/mapvalidator"
	"github.com/hashicorp/terraform-plugin-framework-validators/stringvalidator"
	"github.com/hashicorp/terraform-plugin-framework/path"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/planmodifier"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/stringplanmodifier"
	"github.com/hashicorp/terraform-plugin-framework/schema/validator"
	"github.com/hashicorp/terraform-plugin-framework/types"

	"github.com/jmorris0x0/terraform-provider-k8sconnect/internal/k8sconnect/common/auth"
	"github.com/jmorris0x0/terraform-provider-k8sconnect/internal/k8sconnect/common/factory"
	"github.com/jmorris0x0/terraform-provider-k8sconnect/internal/k8sconnect/common/k8sclient"
)

var _ resource.Resource = (*manifestResource)(nil)
var _ resource.ResourceWithConfigValidators = (*manifestResource)(nil)
var _ resource.ResourceWithModifyPlan = (*manifestResource)(nil)
var _ resource.ResourceWithImportState = (*manifestResource)(nil)
var _ resource.ResourceWithConfigure = (*manifestResource)(nil)

// ClientGetter function type for dependency injection
type ClientGetter func(auth.ClusterConnectionModel) (k8sclient.K8sClient, error)

type manifestResource struct {
	clientGetter  ClientGetter // Keep for now
	clientFactory factory.ClientFactory
}

type manifestResourceModel struct {
	ID                     types.String  `tfsdk:"id"`
	YAMLBody               types.String  `tfsdk:"yaml_body"`
	ClusterConnection      types.Object  `tfsdk:"cluster_connection"`
	DeleteProtection       types.Bool    `tfsdk:"delete_protection"`
	DeleteTimeout          types.String  `tfsdk:"delete_timeout"`
	FieldOwnership         types.Map     `tfsdk:"field_ownership"`
	ForceDestroy           types.Bool    `tfsdk:"force_destroy"`
	ForceConflicts         types.Bool    `tfsdk:"force_conflicts"`
	IgnoreFields           types.List    `tfsdk:"ignore_fields"`
	ManagedStateProjection types.String  `tfsdk:"managed_state_projection"`
	WaitFor                types.Object  `tfsdk:"wait_for"`
	Status                 types.Dynamic `tfsdk:"status"`
}

type waitForModel struct {
	Field      types.String `tfsdk:"field"`
	FieldValue types.Map    `tfsdk:"field_value"`
	Condition  types.String `tfsdk:"condition"`
	Rollout    types.Bool   `tfsdk:"rollout"`
	Timeout    types.String `tfsdk:"timeout"`
}

// Creates a manifest resource with custom client getter
func NewManifestResourceWithClientGetter(getter ClientGetter) resource.Resource {
	return &manifestResource{
		clientGetter: getter,
	}
}

func (r *manifestResource) Metadata(ctx context.Context, req resource.MetadataRequest, resp *resource.MetadataResponse) {
	resp.TypeName = req.ProviderTypeName + "_manifest"
}

func (r *manifestResource) Configure(ctx context.Context, req resource.ConfigureRequest, resp *resource.ConfigureResponse) {
	// Skip if provider data is not available (e.g., during planning)
	if req.ProviderData == nil {
		return
	}

	// Try to get client factory directly (no more ConnectionConfig)
	clientFactory, ok := req.ProviderData.(factory.ClientFactory)
	if !ok {
		resp.Diagnostics.AddError(
			"Unexpected Provider Data Type",
			"Expected factory.ClientFactory but got something else. This is a provider bug.",
		)
		return
	}

	// Store the client factory
	r.clientFactory = clientFactory

	// For backward compatibility, create a clientGetter that uses the factory
	r.clientGetter = func(conn auth.ClusterConnectionModel) (k8sclient.K8sClient, error) {
		return r.clientFactory.GetClient(conn)
	}
}

func (r *manifestResource) Schema(ctx context.Context, req resource.SchemaRequest, resp *resource.SchemaResponse) {
	resp.Schema = schema.Schema{
		Description: "Applies a single‑document Kubernetes YAML manifest to a cluster, with per‑resource inline or kubeconfig‑based connection settings.",
		Attributes: map[string]schema.Attribute{
			"id": schema.StringAttribute{
				Computed: true,
				PlanModifiers: []planmodifier.String{
					stringplanmodifier.UseStateForUnknown(),
				},
				Description: "Unique identifier for this manifest (generated by the provider).",
			},
			"yaml_body": schema.StringAttribute{
				Required:    true,
				Description: "UTF-8 encoded, single-document Kubernetes YAML. Multi-doc files will fail validation.",
				Validators: []validator.String{
					yamlValidator{singleDoc: true},
					serverManagedFieldsValidator{},
				},
			},
			"cluster_connection": schema.SingleNestedAttribute{
				Required:    true,
				Description: "Cluster connection configuration for this resource.",
				Attributes:  auth.GetConnectionSchemaForResource(),
			},
			"delete_protection": schema.BoolAttribute{
				Optional:    true,
				Description: "Prevent accidental deletion of the resource. If set to true, the resource cannot be deleted unless this field is set to false.",
			},
			"delete_timeout": schema.StringAttribute{
				Optional:    true,
				Description: "How long to wait for a resource to be deleted before considering the deletion failed. Defaults to 300s (5 minutes).",
				Validators: []validator.String{
					durationValidator{},
				},
			},
			"force_destroy": schema.BoolAttribute{
				Optional:            true,
				MarkdownDescription: `Force deletion by removing finalizers. ⚠️ **WARNING**: Unlike other providers, this REMOVES finalizers after timeout. May cause data loss and orphaned cloud resources. See docs before using.`,
			},
			"managed_state_projection": schema.StringAttribute{
				Computed:    true,
				Description: "Internal field used to track managed fields for accurate drift detection.",
			},
			"force_conflicts": schema.BoolAttribute{
				Optional:    true,
				Description: "Force field manager conflicts during server-side apply. When false (default), operations will fail if another field manager owns the field. When true, forcibly takes ownership of conflicting fields.",
			},
			"ignore_fields": schema.ListAttribute{
				Optional:    true,
				ElementType: types.StringType,
				Description: "List of field paths to ignore. On Create, these fields are sent to establish initial state. On Update, they are omitted from the Apply patch (releasing ownership to other controllers) and excluded from drift detection. Use dot notation for nested fields (e.g., 'metadata.annotations', 'spec.replicas'). Supports array indices like 'webhooks[0].clientConfig.caBundle' and strategic merge keys like 'spec.containers[name=nginx].image'. Useful for fields modified by controllers (e.g., HPA changing replicas) or operators injecting values.",
				Validators: []validator.List{
					listvalidator.ValueStringsAre(ignoreFieldsValidator{}),
				},
			},
			"field_ownership": schema.MapAttribute{
				Computed:    true,
				ElementType: types.StringType,
				Description: "Field ownership tracking - shows which controller manages each field",
			},
			"status": schema.DynamicAttribute{
				Computed:    true,
				Description: "Status subresource from the live cluster state. Contains conditions, phase, and resource-specific fields like loadBalancer for Services.",
			},
			"wait_for": schema.SingleNestedAttribute{
				Optional:    true,
				Description: "Wait for resource to reach desired state during apply. Automatically enables status tracking.",
				Attributes: map[string]schema.Attribute{
					"field": schema.StringAttribute{
						Optional:    true,
						Description: "JSONPath to field that must exist/be non-empty. Example: 'status.loadBalancer.ingress'",
						Validators: []validator.String{
							stringvalidator.ConflictsWith(
								path.MatchRelative().AtParent().AtName("field_value"),
								path.MatchRelative().AtParent().AtName("condition"),
							),
							jsonPathValidator{}, // Already added
						},
					},
					"field_value": schema.MapAttribute{
						Optional:    true,
						ElementType: types.StringType,
						Description: "Map of JSONPath to expected value. Example: {'status.phase': 'Running'}",
						Validators: []validator.Map{
							mapvalidator.ConflictsWith(
								path.MatchRelative().AtParent().AtName("field"),
								path.MatchRelative().AtParent().AtName("condition"),
							),
							jsonPathMapKeysValidator{}, // New validator for map keys
						},
					},
					"condition": schema.StringAttribute{
						Optional:    true,
						Description: "Condition type that must be True. Example: 'Ready'",
						Validators: []validator.String{
							stringvalidator.ConflictsWith(
								path.MatchRelative().AtParent().AtName("field"),
								path.MatchRelative().AtParent().AtName("field_value"),
							),
						},
					},
					"rollout": schema.BoolAttribute{
						Optional:    true,
						Description: "Wait for Deployment/StatefulSet/DaemonSet rollout. Auto-enabled for these types unless set to false.",
					},
					"timeout": schema.StringAttribute{
						Optional:    true,
						Description: "Maximum time to wait. Defaults to 10m. Format: '30s', '5m', '1h'",
						Validators: []validator.String{
							durationValidator{},
						},
					},
				},
			},
		},
	}
}

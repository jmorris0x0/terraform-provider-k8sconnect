// internal/k8sconnect/resource/manifest/manifest.go
package manifest

import (
	"context"

	"github.com/hashicorp/terraform-plugin-framework/resource"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema"

	"github.com/hashicorp/terraform-plugin-framework-validators/listvalidator"
	"github.com/hashicorp/terraform-plugin-framework-validators/mapvalidator"
	"github.com/hashicorp/terraform-plugin-framework-validators/stringvalidator"
	"github.com/hashicorp/terraform-plugin-framework/path"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/planmodifier"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/stringplanmodifier"
	"github.com/hashicorp/terraform-plugin-framework/schema/validator"
	"github.com/hashicorp/terraform-plugin-framework/types"

	"github.com/jmorris0x0/terraform-provider-k8sconnect/internal/k8sconnect/common/auth"
	"github.com/jmorris0x0/terraform-provider-k8sconnect/internal/k8sconnect/common/factory"
	"github.com/jmorris0x0/terraform-provider-k8sconnect/internal/k8sconnect/common/k8sclient"
)

var _ resource.Resource = (*manifestResource)(nil)
var _ resource.ResourceWithConfigValidators = (*manifestResource)(nil)
var _ resource.ResourceWithModifyPlan = (*manifestResource)(nil)
var _ resource.ResourceWithImportState = (*manifestResource)(nil)
var _ resource.ResourceWithConfigure = (*manifestResource)(nil)

// ClientGetter function type for dependency injection
type ClientGetter func(auth.ClusterConnectionModel) (k8sclient.K8sClient, error)

type manifestResource struct {
	clientGetter  ClientGetter // Keep for now
	clientFactory factory.ClientFactory
}

type manifestResourceModel struct {
	ID                     types.String  `tfsdk:"id"`
	YAMLBody               types.String  `tfsdk:"yaml_body"`
	ClusterConnection      types.Object  `tfsdk:"cluster_connection"`
	DeleteProtection       types.Bool    `tfsdk:"delete_protection"`
	DeleteTimeout          types.String  `tfsdk:"delete_timeout"`
	FieldOwnership         types.Map     `tfsdk:"field_ownership"`
	ForceDestroy           types.Bool    `tfsdk:"force_destroy"`
	IgnoreFields           types.List    `tfsdk:"ignore_fields"`
	ManagedStateProjection types.String  `tfsdk:"managed_state_projection"`
	WaitFor                types.Object  `tfsdk:"wait_for"`
	Status                 types.Dynamic `tfsdk:"status"`
}

type waitForModel struct {
	Field      types.String `tfsdk:"field"`
	FieldValue types.Map    `tfsdk:"field_value"`
	Condition  types.String `tfsdk:"condition"`
	Rollout    types.Bool   `tfsdk:"rollout"`
	Timeout    types.String `tfsdk:"timeout"`
}

// Creates a manifest resource with custom client getter
func NewManifestResourceWithClientGetter(getter ClientGetter) resource.Resource {
	return &manifestResource{
		clientGetter: getter,
	}
}

func (r *manifestResource) Metadata(ctx context.Context, req resource.MetadataRequest, resp *resource.MetadataResponse) {
	resp.TypeName = req.ProviderTypeName + "_manifest"
}

func (r *manifestResource) Configure(ctx context.Context, req resource.ConfigureRequest, resp *resource.ConfigureResponse) {
	// Skip if provider data is not available (e.g., during planning)
	if req.ProviderData == nil {
		return
	}

	// Try to get client factory directly (no more ConnectionConfig)
	clientFactory, ok := req.ProviderData.(factory.ClientFactory)
	if !ok {
		resp.Diagnostics.AddError(
			"Unexpected Provider Data Type",
			"Expected factory.ClientFactory but got something else. This is a provider bug.",
		)
		return
	}

	// Store the client factory
	r.clientFactory = clientFactory

	// For backward compatibility, create a clientGetter that uses the factory
	r.clientGetter = func(conn auth.ClusterConnectionModel) (k8sclient.K8sClient, error) {
		return r.clientFactory.GetClient(conn)
	}
}

func (r *manifestResource) Schema(ctx context.Context, req resource.SchemaRequest, resp *resource.SchemaResponse) {
	resp.Schema = schema.Schema{
		Description: "Applies a single‑document Kubernetes YAML manifest to a cluster, with per‑resource inline or kubeconfig‑based connection settings.",
		Attributes: map[string]schema.Attribute{
			"id": schema.StringAttribute{
				Computed: true,
				PlanModifiers: []planmodifier.String{
					stringplanmodifier.UseStateForUnknown(),
				},
				Description: "Unique identifier for this manifest (generated by the provider).",
			},
			"yaml_body": schema.StringAttribute{
				Required:    true,
				Description: "UTF-8 encoded, single-document Kubernetes YAML. Multi-doc files will fail validation.",
				Validators: []validator.String{
					yamlValidator{singleDoc: true},
					serverManagedFieldsValidator{},
				},
			},
			"cluster_connection": schema.SingleNestedAttribute{
				Required: true,
				Description: "Kubernetes cluster connection for this specific resource. Can be different per-resource, enabling multi-cluster " +
					"deployments without provider aliases. Supports inline credentials (token, exec, client certs) or kubeconfig.",
				Attributes: auth.GetConnectionSchemaForResource(),
			},
			"delete_protection": schema.BoolAttribute{
				Optional:    true,
				Description: "Prevent accidental deletion of the resource. If set to true, the resource cannot be deleted unless this field is set to false.",
			},
			"delete_timeout": schema.StringAttribute{
				Optional:    true,
				Description: "How long to wait for a resource to be deleted before considering the deletion failed. Defaults to 300s (5 minutes).",
				Validators: []validator.String{
					durationValidator{},
				},
			},
			"force_destroy": schema.BoolAttribute{
				Optional:            true,
				MarkdownDescription: `Force deletion by removing finalizers. ⚠️ **WARNING**: Unlike other providers, this REMOVES finalizers after timeout. May cause data loss and orphaned cloud resources. See docs before using.`,
			},
			"managed_state_projection": schema.StringAttribute{
				Computed: true,
				Description: "Snapshot of resource state from the last Server-Side Apply dry-run, containing only fields managed by k8sconnect. " +
					"When this differs from current cluster state, it indicates drift - someone modified your managed fields outside Terraform. " +
					"During plan, diffs in this attribute show exactly what Kubernetes will change when you apply, computed via dry-run for accuracy. " +
					"This enables precise drift detection without false positives from fields managed by other controllers.",
			},
			"ignore_fields": schema.ListAttribute{
				Optional:    true,
				ElementType: types.StringType,
				Description: "Field paths to exclude from management. On Create, fields are sent to establish initial state; " +
					"on Update, they're omitted from the Apply patch, releasing ownership to other controllers and excluding them from drift detection. " +
					"Supports dot notation (e.g., 'metadata.annotations', 'spec.replicas'), array indices ('webhooks[0].clientConfig.caBundle'), " +
					"and strategic merge keys ('spec.containers[name=nginx].image'). Use for fields managed by controllers (e.g., HPA modifying replicas) " +
					"or when operators inject values.",
				Validators: []validator.List{
					listvalidator.ValueStringsAre(ignoreFieldsValidator{}),
				},
			},
			"field_ownership": schema.MapAttribute{
				Computed:    true,
				ElementType: types.StringType,
				Description: "Tracks which controller owns each managed field using Server-Side Apply field management. " +
					"Shows as a map of 'field.path': 'controller-name'. Only appears in plan diffs when ownership actually changes " +
					"(e.g., when HPA takes ownership of spec.replicas). Empty/hidden when ownership is unchanged. " +
					"Critical for understanding SSA conflicts and knowing which controller controls what.",
			},
			"status": schema.DynamicAttribute{
				Computed: true,
				Description: "Resource status from the cluster, populated only when using wait_for with field='status.path'. " +
					"Contains resource-specific runtime information like LoadBalancer IPs, Pod conditions, Deployment replicas. " +
					"Follows the principle: 'You get only what you wait for' to avoid storing volatile status fields that cause drift. " +
					"Returns null when wait_for is not configured or uses non-field wait types.",
			},
			"wait_for": schema.SingleNestedAttribute{
				Optional:    true,
				Description: "Wait for resource to reach desired state during apply. Automatically enables status tracking.",
				Attributes: map[string]schema.Attribute{
					"field": schema.StringAttribute{
						Optional:    true,
						Description: "JSONPath to field that must exist/be non-empty. Example: 'status.loadBalancer.ingress'",
						Validators: []validator.String{
							stringvalidator.ConflictsWith(
								path.MatchRelative().AtParent().AtName("field_value"),
								path.MatchRelative().AtParent().AtName("condition"),
							),
							jsonPathValidator{}, // Already added
						},
					},
					"field_value": schema.MapAttribute{
						Optional:    true,
						ElementType: types.StringType,
						Description: "Map of JSONPath to expected value. Example: {'status.phase': 'Running'}",
						Validators: []validator.Map{
							mapvalidator.ConflictsWith(
								path.MatchRelative().AtParent().AtName("field"),
								path.MatchRelative().AtParent().AtName("condition"),
							),
							jsonPathMapKeysValidator{}, // New validator for map keys
						},
					},
					"condition": schema.StringAttribute{
						Optional:    true,
						Description: "Condition type that must be True. Example: 'Ready'",
						Validators: []validator.String{
							stringvalidator.ConflictsWith(
								path.MatchRelative().AtParent().AtName("field"),
								path.MatchRelative().AtParent().AtName("field_value"),
							),
						},
					},
					"rollout": schema.BoolAttribute{
						Optional: true,
						Description: "Wait for Deployment/StatefulSet/DaemonSet to complete rollout before considering the resource ready. " +
							"Optional - rollout waiting is not automatic. Checks that all replicas are updated and available.",
					},
					"timeout": schema.StringAttribute{
						Optional:    true,
						Description: "Maximum time to wait. Defaults to 10m. Format: '30s', '5m', '1h'",
						Validators: []validator.String{
							durationValidator{},
						},
					},
				},
			},
		},
	}
}

// internal/k8sinline/resource/manifest/manifest.go
package manifest

import (
	"context"

	"github.com/hashicorp/terraform-plugin-framework/resource"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/planmodifier"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/stringplanmodifier"
	"github.com/hashicorp/terraform-plugin-framework/types"

	"github.com/jmorris0x0/terraform-provider-k8sinline/internal/k8sinline/common"
	"github.com/jmorris0x0/terraform-provider-k8sinline/internal/k8sinline/common/auth"
	"github.com/jmorris0x0/terraform-provider-k8sinline/internal/k8sinline/common/client"
	"github.com/jmorris0x0/terraform-provider-k8sinline/internal/k8sinline/k8sclient"
)

var _ resource.Resource = (*manifestResource)(nil)
var _ resource.ResourceWithConfigValidators = (*manifestResource)(nil)
var _ resource.ResourceWithModifyPlan = (*manifestResource)(nil)
var _ resource.ResourceWithImportState = (*manifestResource)(nil)
var _ resource.ResourceWithConfigure = (*manifestResource)(nil)

// ClientGetter function type for dependency injection
type ClientGetter func(auth.ClusterConnectionModel) (k8sclient.K8sClient, error)

type manifestResource struct {
	clientGetter ClientGetter // Keep for backward compatibility

	// New fields for connection config
	connResolver  *auth.ConnectionResolver
	clientFactory client.ClientFactory
}

type manifestResourceModel struct {
	ID                         types.String `tfsdk:"id"`
	YAMLBody                   types.String `tfsdk:"yaml_body"`
	ClusterConnection          types.Object `tfsdk:"cluster_connection"`
	DeleteProtection           types.Bool   `tfsdk:"delete_protection"`
	DeleteTimeout              types.String `tfsdk:"delete_timeout"`
	ForceDestroy               types.Bool   `tfsdk:"force_destroy"`
	ManagedStateProjection     types.String `tfsdk:"managed_state_projection"`
	ImportedWithoutAnnotations types.Bool   `tfsdk:"imported_without_annotations"`
}

// NewManifestResourceWithClientGetter creates a manifest resource with custom client getter
func NewManifestResourceWithClientGetter(getter ClientGetter) resource.Resource {
	return &manifestResource{
		clientGetter: getter,
	}
}

func (r *manifestResource) Metadata(ctx context.Context, req resource.MetadataRequest, resp *resource.MetadataResponse) {
	resp.TypeName = req.ProviderTypeName + "_manifest"
}

func (r *manifestResource) Configure(ctx context.Context, req resource.ConfigureRequest, resp *resource.ConfigureResponse) {
	// Skip if provider data is not available (e.g., during planning)
	if req.ProviderData == nil {
		return
	}

	// Try to get connection config
	connectionConfig, ok := req.ProviderData.(*common.ConnectionConfig)
	if !ok {
		resp.Diagnostics.AddError(
			"Unexpected Provider Data Type",
			"Expected *common.ConnectionConfig but got something else. This is a provider bug.",
		)
		return
	}

	// Store the components
	r.connResolver = connectionConfig.ConnectionResolver
	r.clientFactory = connectionConfig.ClientFactory

	// For backward compatibility, create a clientGetter that uses the factory
	r.clientGetter = func(conn auth.ClusterConnectionModel) (k8sclient.K8sClient, error) {
		return r.clientFactory.GetClient(conn)
	}
}

func (r *manifestResource) Schema(ctx context.Context, req resource.SchemaRequest, resp *resource.SchemaResponse) {
	resp.Schema = schema.Schema{
		Description: "Applies a single‑document Kubernetes YAML manifest to a cluster, with per‑resource inline or kubeconfig‑based connection settings.",
		Attributes: map[string]schema.Attribute{
			"id": schema.StringAttribute{
				Computed: true,
				PlanModifiers: []planmodifier.String{
					stringplanmodifier.UseStateForUnknown(),
				},
				Description: "Unique identifier for this manifest (generated by the provider).",
			},
			"yaml_body": schema.StringAttribute{
				Required:    true,
				Description: "UTF‑8 encoded, single‑document Kubernetes YAML. Multi‑doc files will fail validation.",
			},
			"cluster_connection": schema.SingleNestedAttribute{
				Optional:    true, // Changed from Required to Optional
				Description: "Cluster connection configuration for this resource. If not specified, uses the provider-level connection.",
				Attributes: map[string]schema.Attribute{
					"host": schema.StringAttribute{
						Optional:    true,
						Description: "The hostname (in form of URI) of the Kubernetes API server.",
					},
					"cluster_ca_certificate": schema.StringAttribute{
						Optional:    true,
						Description: "PEM-encoded root certificate bundle for TLS authentication.",
					},
					"kubeconfig_file": schema.StringAttribute{
						Optional:    true,
						Description: "Path to the kubeconfig file.",
					},
					"kubeconfig_raw": schema.StringAttribute{
						Optional:    true,
						Sensitive:   true,
						Description: "Raw kubeconfig file content.",
					},
					"context": schema.StringAttribute{
						Optional:    true,
						Description: "Context to use from the kubeconfig.",
					},
					"token": schema.StringAttribute{
						Optional:    true,
						Sensitive:   true,
						Description: "Token to authenticate to the Kubernetes API server.",
					},
					"client_certificate": schema.StringAttribute{
						Optional:    true,
						Description: "PEM-encoded client certificate for TLS authentication.",
					},
					"client_key": schema.StringAttribute{
						Optional:    true,
						Sensitive:   true,
						Description: "PEM-encoded client certificate key for TLS authentication.",
					},
					"insecure": schema.BoolAttribute{
						Optional:    true,
						Description: "Whether server should be accessed without verifying the TLS certificate.",
					},
					"proxy_url": schema.StringAttribute{
						Optional:    true,
						Description: "URL of the proxy to use for requests.",
					},
					"exec": schema.SingleNestedAttribute{
						Optional:    true,
						Description: "Configuration for exec-based authentication.",
						Attributes: map[string]schema.Attribute{
							"api_version": schema.StringAttribute{
								Required:    true,
								Description: "API version to use when encoding the ExecCredentials resource.",
							},
							"command": schema.StringAttribute{
								Required:    true,
								Description: "Command to execute.",
							},
							"args": schema.ListAttribute{
								Optional:    true,
								ElementType: types.StringType,
								Description: "Arguments to pass when executing the plugin.",
							},
							"env": schema.MapAttribute{
								Optional:    true,
								ElementType: types.StringType,
								Description: "Environment variables to set when executing the plugin.",
							},
						},
					},
				},
			},
			"delete_protection": schema.BoolAttribute{
				Optional:    true,
				Description: "Prevent accidental deletion of the resource. If set to true, the resource cannot be deleted unless this field is set to false.",
			},
			"delete_timeout": schema.StringAttribute{
				Optional:    true,
				Description: "How long to wait for a resource to be deleted before considering the deletion failed. Defaults to 300s (5 minutes).",
			},
			"force_destroy": schema.BoolAttribute{
				Optional:    true,
				Description: "Force destroy resources that have finalizers and are stuck in 'Terminating' state. This removes finalizers before deletion.",
			},
			"managed_state_projection": schema.StringAttribute{
				Computed:    true,
				Description: "Internal field used to track managed fields for accurate drift detection.",
			},
			"imported_without_annotations": schema.BoolAttribute{
				Computed:    true,
				Description: "Internal flag tracking if resource was imported without ownership annotations",
			},
		},
	}
}

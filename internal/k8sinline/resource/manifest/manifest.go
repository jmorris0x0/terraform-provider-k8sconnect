// internal.k8sinline/resource/manifest/manifest.go
package manifest

import (
	"context"

	"github.com/hashicorp/terraform-plugin-framework/path"
	"github.com/hashicorp/terraform-plugin-framework/resource"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/planmodifier"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/stringplanmodifier"
	"github.com/hashicorp/terraform-plugin-framework/types"
	"github.com/hashicorp/terraform-plugin-log/tflog"
)

var _ resource.Resource = (*manifestResource)(nil)

func NewManifestResource() resource.Resource {
	return &manifestResource{}
}

type manifestResource struct{}

func (r *manifestResource) Metadata(ctx context.Context, req resource.MetadataRequest, resp *resource.MetadataResponse) {
	resp.TypeName = req.ProviderTypeName + "_manifest"
}

func (r *manifestResource) Schema(ctx context.Context, req resource.SchemaRequest, resp *resource.SchemaResponse) {
	resp.Schema = schema.Schema{
		Description: "Applies a single‑document Kubernetes YAML manifest to a cluster, with per‑resource inline or kubeconfig‑based connection settings.",
		Attributes: map[string]schema.Attribute{
			"id": schema.StringAttribute{
				Computed: true,
				PlanModifiers: []planmodifier.String{
					stringplanmodifier.UseStateForUnknown(),
				},
				Description: "Unique identifier for this manifest (generated by the provider).",
			},
			"yaml_body": schema.StringAttribute{
				Required:    true,
				Description: "UTF‑8 encoded, single‑document Kubernetes YAML. Multi‑doc files will fail validation.",
			},
		},
		Blocks: map[string]schema.Block{
			"cluster_connection": schema.SingleNestedBlock{
				Required:    true,
				Description: "Connection settings for the target cluster. Exactly one of inline, kubeconfig_file or kubeconfig_raw must be populated.",
				Attributes: map[string]schema.Attribute{
					"host": schema.StringAttribute{
						Optional:    true,
						Sensitive:   true,
						Description: "Kubernetes API server endpoint (e.g. https://example.com). Required for inline mode.",
					},
					"cluster_ca_certificate": schema.StringAttribute{
						Optional:    true,
						Sensitive:   true,
						Description: "PEM‑encoded CA certificate bundle for the API server. Required for inline mode.",
					},
					"kubeconfig_file": schema.StringAttribute{
						Optional:    true,
						Sensitive:   true,
						Description: "Filesystem path to an existing kubeconfig file. Always supports live diffing.",
					},
					"kubeconfig_raw": schema.StringAttribute{
						Optional:    true,
						Sensitive:   true,
						Description: "Raw kubeconfig YAML content (CI‑friendly).",
					},
					"context": schema.StringAttribute{
						Optional:    true,
						Sensitive:   true,
						Description: "Context name within the provided kubeconfig (file or raw).",
					},
					"exec": schema.ObjectAttribute{
						Optional:    true,
						Sensitive:   true,
						Description: "Inline exec‑auth configuration for dynamic credentials. Must include `api_version` and `command`, optional `args`.",
						Attributes: map[string]schema.Attribute{
							"api_version": schema.StringAttribute{
								Required:    true,
								Sensitive:   true,
								Description: "Exec auth API version (e.g. client.authentication.k8s.io/v1beta1).",
							},
							"command": schema.StringAttribute{
								Required:    true,
								Sensitive:   true,
								Description: "Executable command for retrieving credentials (e.g. aws).",
							},
							"args": schema.ListAttribute{
								ElementType: types.StringType,
								Optional:    true,
								Sensitive:   true,
								Description: "Arguments to pass to the exec command.",
							},
						},
					},
				},
			},
		},
	}
}

type manifestResourceModel struct {
	ID                types.String           `tfsdk:"id"`
	YAMLBody          types.String           `tfsdk:"yaml_body"`
	ClusterConnection clusterConnectionModel `tfsdk:"cluster_connection"`
}

type clusterConnectionModel struct {
	Host                 types.String  `tfsdk:"host"`
	ClusterCACertificate types.String  `tfsdk:"cluster_ca_certificate"`
	KubeconfigFile       types.String  `tfsdk:"kubeconfig_file"`
	KubeconfigRaw        types.String  `tfsdk:"kubeconfig_raw"`
	Context              types.String  `tfsdk:"context"`
	Exec                 execAuthModel `tfsdk:"exec"`
}

type execAuthModel struct {
	APIVersion types.String   `tfsdk:"api_version"`
	Command    types.String   `tfsdk:"command"`
	Args       []types.String `tfsdk:"args"`
}

func (r *manifestResource) Create(ctx context.Context, req resource.CreateRequest, resp *resource.CreateResponse) {
	var data manifestResourceModel

	diags := req.Config.Get(ctx, &data)
	resp.Diagnostics.Append(diags...)
	if resp.Diagnostics.HasError() {
		return
	}

	// TODO: implement kubectl apply logic using data.YAMLBody and data.ClusterConnection

	data.ID = types.StringValue("generated-id") // replace with actual generated ID
	tflog.Trace(ctx, "applied manifest", map[string]interface{}{
		"id": data.ID.ValueString(),
	})

	diags = resp.State.Set(ctx, &data)
	resp.Diagnostics.Append(diags...)
}

func (r *manifestResource) Read(ctx context.Context, req resource.ReadRequest, resp *resource.ReadResponse) {
	var data manifestResourceModel

	diags := req.State.Get(ctx, &data)
	resp.Diagnostics.Append(diags...)
	if resp.Diagnostics.HasError() {
		return
	}

	// TODO: refresh state from cluster

	diags = resp.State.Set(ctx, &data)
	resp.Diagnostics.Append(diags...)
}

func (r *manifestResource) Update(ctx context.Context, req resource.UpdateRequest, resp *resource.UpdateResponse) {
	var data manifestResourceModel

	diags := req.Plan.Get(ctx, &data)
	resp.Diagnostics.Append(diags...)
	if resp.Diagnostics.HasError() {
		return
	}

	// TODO: implement server-side diff & apply

	diags = resp.State.Set(ctx, &data)
	resp.Diagnostics.Append(diags...)
}

func (r *manifestResource) Delete(ctx context.Context, req resource.DeleteRequest, resp *resource.DeleteResponse) {
	var data manifestResourceModel

	diags := req.State.Get(ctx, &data)
	resp.Diagnostics.Append(diags...)
	if resp.Diagnostics.HasError() {
		return
	}

	// TODO: implement kubectl delete

	tflog.Trace(ctx, "deleted manifest", map[string]interface{}{
		"id": data.ID.ValueString(),
	})
}

func (r *manifestResource) ImportState(ctx context.Context, req resource.ImportStateRequest, resp *resource.ImportStateResponse) {
	resp.Diagnostics.Append(
		resp.State.SetAttribute(ctx, path.Root("id"), req.ID)...,
	)
}

// internal/k8sinline/resource/manifest/manifest.go
package manifest

import (
	"context"

	"github.com/hashicorp/terraform-plugin-framework/resource"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/planmodifier"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/stringplanmodifier"
	"github.com/hashicorp/terraform-plugin-framework/types"

	"github.com/jmorris0x0/terraform-provider-k8sinline/internal/k8sinline/k8sclient"
)

var _ resource.Resource = (*manifestResource)(nil)

var _ resource.ResourceWithConfigValidators = (*manifestResource)(nil)

var _ resource.ResourceWithModifyPlan = (*manifestResource)(nil)

// ClientGetter function type for dependency injection
type ClientGetter func(ClusterConnectionModel) (k8sclient.K8sClient, error)

// ClusterConnectionModel is exported for use in provider
type ClusterConnectionModel struct {
	Host                 types.String   `tfsdk:"host"`
	ClusterCACertificate types.String   `tfsdk:"cluster_ca_certificate"`
	KubeconfigFile       types.String   `tfsdk:"kubeconfig_file"`
	KubeconfigRaw        types.String   `tfsdk:"kubeconfig_raw"`
	Context              types.String   `tfsdk:"context"`
	Exec                 *execAuthModel `tfsdk:"exec"`
}

type execAuthModel struct {
	APIVersion types.String            `tfsdk:"api_version"`
	Command    types.String            `tfsdk:"command"`
	Args       []types.String          `tfsdk:"args"`
	Env        map[string]types.String `tfsdk:"env"`
}

type manifestResource struct {
	clientGetter ClientGetter
}

type manifestResourceModel struct {
	ID                     types.String `tfsdk:"id"`
	YAMLBody               types.String `tfsdk:"yaml_body"`
	ClusterConnection      types.Object `tfsdk:"cluster_connection"`
	DeleteProtection       types.Bool   `tfsdk:"delete_protection"`
	DeleteTimeout          types.String `tfsdk:"delete_timeout"`
	ForceDestroy           types.Bool   `tfsdk:"force_destroy"`
	ManagedStateProjection types.String `tfsdk:"managed_state_projection"`
}

// NewManifestResource creates a new manifest resource (backward compatibility)
func NewManifestResource() resource.Resource {
	return &manifestResource{
		clientGetter: CreateK8sClientFromConnection,
	}
}

// NewManifestResourceWithClientGetter creates a manifest resource with custom client getter
func NewManifestResourceWithClientGetter(getter ClientGetter) resource.Resource {
	return &manifestResource{
		clientGetter: getter,
	}
}

func (r *manifestResource) Metadata(ctx context.Context, req resource.MetadataRequest, resp *resource.MetadataResponse) {
	resp.TypeName = req.ProviderTypeName + "_manifest"
}

// Enhanced Schema method with single nested attribute instead of block
func (r *manifestResource) Schema(ctx context.Context, req resource.SchemaRequest, resp *resource.SchemaResponse) {
	resp.Schema = schema.Schema{
		Description: "Applies a single‑document Kubernetes YAML manifest to a cluster, with per‑resource inline or kubeconfig‑based connection settings.",
		Attributes: map[string]schema.Attribute{
			"id": schema.StringAttribute{
				Computed: true,
				PlanModifiers: []planmodifier.String{
					stringplanmodifier.UseStateForUnknown(),
				},
				Description: "Unique identifier for this manifest (generated by the provider).",
			},
			"yaml_body": schema.StringAttribute{
				Required:    true,
				Description: "UTF‑8 encoded, single‑document Kubernetes YAML. Multi‑doc files will fail validation.",
			},
			"managed_state_projection": schema.StringAttribute{
				Computed:    true,
				Sensitive:   false,
				Description: "JSON projection of Kubernetes state for fields managed by this resource",
				PlanModifiers: []planmodifier.String{
					stringplanmodifier.UseStateForUnknown(),
				},
			},
			"delete_protection": schema.BoolAttribute{
				Optional:    true,
				Description: "When enabled, prevents Terraform from deleting this resource. Must be disabled before destruction. Defaults to false.",
			},
			"delete_timeout": schema.StringAttribute{
				Optional:    true,
				Description: "Maximum time to wait for resource deletion. Defaults to '5m' for most resources, '10m' for Namespaces/PVs. Examples: '1m', '10m', '1h'. Set '0' to skip waiting (not recommended).",
			},
			"force_destroy": schema.BoolAttribute{
				Optional:    true,
				Description: "When enabled, removes finalizers to force deletion if normal deletion times out. ⚠️ WARNING: May cause data loss. Use only when you understand the implications. Defaults to false.",
			},
			"cluster_connection": schema.SingleNestedAttribute{
				Required:    true,
				Description: "Connection settings for the target cluster. Exactly one of inline, kubeconfig_file or kubeconfig_raw must be populated.",
				Attributes: map[string]schema.Attribute{
					"host": schema.StringAttribute{
						Optional:    true,
						Sensitive:   true,
						Description: "Kubernetes API server endpoint (e.g. https://example.com). Required for inline mode.",
					},
					"cluster_ca_certificate": schema.StringAttribute{
						Optional:    true,
						Sensitive:   true,
						Description: "PEM‑encoded CA certificate bundle for the API server. Required for inline mode.",
					},
					"kubeconfig_file": schema.StringAttribute{
						Optional:    true,
						Sensitive:   true,
						Description: "Filesystem path to an existing kubeconfig file. Always supports live diffing.",
					},
					"kubeconfig_raw": schema.StringAttribute{
						Optional:    true,
						Sensitive:   true,
						Description: "Raw kubeconfig YAML content (CI‑friendly).",
					},
					"context": schema.StringAttribute{
						Optional:    true,
						Sensitive:   true,
						Description: "Context name within the provided kubeconfig (file or raw).",
					},
					"exec": schema.SingleNestedAttribute{
						Description: "Inline exec‑auth configuration for dynamic credentials...",
						Optional:    true,
						Sensitive:   true,
						Attributes: map[string]schema.Attribute{
							"api_version": schema.StringAttribute{
								Optional:    true,
								Description: "Authentication API version (e.g., 'client.authentication.k8s.io/v1').",
							},
							"command": schema.StringAttribute{
								Optional:    true,
								Description: "Executable command (e.g., 'aws', 'gcloud').",
							},
							"args": schema.ListAttribute{
								ElementType: types.StringType,
								Optional:    true,
								Description: "Command arguments (e.g., ['eks', 'get-token', '--cluster-name', 'my-cluster']).",
							},
							// ADD THIS:
							"env": schema.MapAttribute{
								ElementType: types.StringType,
								Optional:    true,
								Description: "Environment variables to set when executing the command (e.g., AWS_PROFILE = 'prod').",
							},
						},
					},
				},
			},
		},
	}
}
